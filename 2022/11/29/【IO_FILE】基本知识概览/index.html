<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <title>Loora1N&#39;s Blog | é¹­é›¨ | </title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="post-header">
    <a class="logo" href="/">Loora1N&#39;s Blog | é¹­é›¨</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#000" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
                
                <div class="post-main">

    
    
        <div class="post-main-title">
            ã€IO_FILEã€‘æºç è¯¦è§£
        </div>
        <div class="post-meta">
            2022-11-29
        </div>
        <div class="post-md">
            <blockquote>
<p>ç”±äºglibcç‰ˆæœ¬çš„ä¸æ–­æ›´æ–°ï¼Œå¸¸è§å‡ ç§hookåœ¨glibc2.34ç»ˆè¢«èˆå»ï¼Œæˆ‘ä»¬æ€¥éœ€ä¸€ç§èƒ½å¤Ÿåœ¨é«˜ç‰ˆæœ¬çš„glibcä¸‹ä»èƒ½æœ‰æ•ˆçš„getshellæ–¹æ³•ã€‚è€ŒIO_FILEä½œä¸ºheapé¢˜ç›®çš„è¿›é˜¶æŠ€èƒ½é€æ¸å¼•èµ·å¤§å®¶æ³¨æ„ï¼Œå¸å¼•äº†è®¸å¤šå¤§ä½¬æŠ•å…¥å…¶ä¸­ã€‚ä»…åœ¨åœ¨2021-2022å¹´æœŸé—´å°±å‡ºç°å‡ºç°äº†å¤§é‡ä»¥IO_FILEä¸ºåŸºç¡€çš„è°ƒç”¨é“¾åˆ©ç”¨æ–¹å¼ï¼Œåœ¨æ¯”èµ›ä¸­ä¹Ÿé€æ¸æˆä¸ºäº†å½“ä¸‹heapé¢˜ç›®çš„ä¸»æµgetshellæ–¹å¼ã€‚æœ¬æ–‡ä»¥glibc2.36ä¸ºä¾‹ï¼Œä»ç›¸å…³ç»“æ„ä½“ä»¥åŠfopenå‡½æ•°æºç å…¥æ‰‹ï¼Œè¯¦ç»†ä»‹ç»IO_FILEç›¸å…³çŸ¥è¯†ç‚¹ã€‚</p>
</blockquote>
<h2 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="_IO_FILE"></a>_IO_FILE</h2><p>IO_FILEç»“æ„ä½“å®šä¹‰ä¸º<code>struct _IO_FILE</code>ï¼š</p>
<pre><code class="c">/* The tag name of this struct is _IO_FILE to preserve historic
   C++ mangled names for functions taking FILE* arguments.
   That name should not be used in new code.  */
struct _IO_FILE
&#123;
  int _flags;		/* High-order word is _IO_MAGIC; rest is flags. */

  /* The following pointers correspond to the C++ streambuf protocol. */
  char *_IO_read_ptr;	/* Current read pointer */
  char *_IO_read_end;	/* End of get area. */
  char *_IO_read_base;	/* Start of putback+get area. */
  char *_IO_write_base;	/* Start of put area. */
  char *_IO_write_ptr;	/* Current put pointer. */
  char *_IO_write_end;	/* End of put area. */
  char *_IO_buf_base;	/* Start of reserve area. */
  char *_IO_buf_end;	/* End of reserve area. */

  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset; /* This used to be _offset but it&#39;s too small.  */

  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
&#125;;

struct _IO_FILE_complete
&#123;
  struct _IO_FILE _file;
#endif
  __off64_t _offset;
  /* Wide character stream stuff.  */
  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;
  /* Make sure we don&#39;t get into trouble again.  */
  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
&#125;;
</code></pre>
<p>ç„¶åè®©æˆ‘ä»¬çœ‹è¿™ä¸ªç»“æ„ä¸­çš„ä¸€äº›é‡è¦éƒ¨åˆ†ï¼š</p>
<ul>
<li><code>_flags</code>:é«˜ä½å­—ä¸º<code>_IO_MAGIC</code>ï¼Œå‰©ä½™çš„éƒ¨åˆ†æ˜¯flag</li>
<li><code>_IO_read_ptr</code>æ­£åœ¨ä½¿ç”¨çš„inputç¼“å†²åŒºçš„inputåœ°å€</li>
<li><code>_IO_read_end</code> inputç¼“å†²åŒºçš„ç»“æŸåœ°å€</li>
<li><code>_IO_read_base</code> inputç¼“å†²åŒºçš„åŸºå€</li>
<li><code>_IO_write_base</code> outputç¼“å†²åŒºçš„åŸºå€</li>
<li><code>_IO_write_ptr</code> æŒ‡å‘è¿˜æ²¡è¾“å‡ºçš„é‚£ä¸ªå­—èŠ‚</li>
<li><code>_IO_write_end</code> outputç¼“å†²åŒºçš„ç»“æŸåœ°å€</li>
<li><code>_IO_buf_base</code> inputå’Œoutputç¼“å†²åŒºçš„åŸºå€</li>
<li><code>_IO_buf_end</code>  inputå’Œoutputç¼“å†²åŒºçš„ç»“æŸåœ°å€</li>
<li><code>_chain</code> å­˜æ”¾ç€ä¸€ä¸ªå•é“¾è¡¨ï¼Œç”¨äºä¸²è”æ‰€æœ‰çš„file stream</li>
<li><code>_fileno</code> ä¸æ–‡ä»¶ç›¸å…³çš„æ–‡ä»¶æè¿°ç¬¦</li>
<li><code>_vtable_offset</code> å­˜æ”¾è™šè¡¨(virtual table)çš„åç§»</li>
<li><code>_offset</code> å­˜æ”¾å½“å‰æ–‡ä»¶çš„åç§»</li>
</ul>
<h2 id="IO-FILE-plus"><a href="#IO-FILE-plus" class="headerlink" title="_IO_FILE_plus"></a>_IO_FILE_plus</h2><pre><code class="c">// https://elixir.bootlin.com/glibc/glibc-2.36/source/libio/libioP.h#L324

struct _IO_FILE_plus
&#123;
  FILE file;
  const struct _IO_jump_t *vtable;
&#125;;
</code></pre>
<p>è¿™é‡ŒFILEå…¶å®å°±æ˜¯_IO_FILEï¼Œæ¢äº†ä¸ªåå­—ç½¢äº†ï¼Œå¦‚ä¸‹æ‰€ç¤ºã€‚ä¸å¾—ä¸è¯´ï¼Œglibcæºç é‡Œå®å®šä¹‰æ˜¯çœŸçš„å¤šğŸ˜…ï¼Œæœ‰ç‚¹æ¶å¿ƒäººã€‚</p>
<pre><code class="c">// https://elixir.bootlin.com/glibc/glibc-2.36/source/libio/bits/types/FILE.h#L7

#ifndef __FILE_defined
#define __FILE_defined 1

struct _IO_FILE;

/* The opaque type of streams.  This is the definition used elsewhere.  */
typedef struct _IO_FILE FILE;

#endif
</code></pre>
<h2 id="IO-jump-t"><a href="#IO-jump-t" class="headerlink" title="_IO_jump_t"></a>_IO_jump_t</h2><p>å¯ä»¥æ³¨æ„åˆ°ï¼Œåœ¨<code>_IO_FILE_plus</code>ä¸­ï¼Œå‰ä¸€éƒ¨åˆ†æ˜¯<code>_IO_FILE</code>ç»“æ„ä½“ï¼Œåä¸€éƒ¨åˆ†æ˜¯æŒ‡å‘<code>_IO_jump_t</code>ç»“æ„ä½“çš„<strong>vtable</strong>æŒ‡é’ˆï¼Œè¿™é‡Œçš„vtableå°±æ˜¯<strong>virtual table</strong>çš„ç¼©å†™ï¼Œå³æˆ‘ä»¬å¸¸è¯´çš„è™šè¡¨ã€‚æ‰€ä»¥<code>_IO_jump_t</code>å…¶å®å°±æ˜¯è™šè¡¨,æºç å®šä¹‰å¦‚ä¸‹ï¼š</p>
<pre><code class="c">// https://elixir.bootlin.com/glibc/glibc-2.36/source/libio/libioP.h#L293

struct _IO_jump_t
&#123;
    JUMP_FIELD(size_t, __dummy);
    JUMP_FIELD(size_t, __dummy2);
    JUMP_FIELD(_IO_finish_t, __finish);
    JUMP_FIELD(_IO_overflow_t, __overflow);
    JUMP_FIELD(_IO_underflow_t, __underflow);
    JUMP_FIELD(_IO_underflow_t, __uflow);
    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);
    /* showmany */
    JUMP_FIELD(_IO_xsputn_t, __xsputn);
    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);
    JUMP_FIELD(_IO_seekoff_t, __seekoff);
    JUMP_FIELD(_IO_seekpos_t, __seekpos);
    JUMP_FIELD(_IO_setbuf_t, __setbuf);
    JUMP_FIELD(_IO_sync_t, __sync);
    JUMP_FIELD(_IO_doallocate_t, __doallocate);
    JUMP_FIELD(_IO_read_t, __read);
    JUMP_FIELD(_IO_write_t, __write);
    JUMP_FIELD(_IO_seek_t, __seek);
    JUMP_FIELD(_IO_close_t, __close);
    JUMP_FIELD(_IO_stat_t, __stat);
    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);
    JUMP_FIELD(_IO_imbue_t, __imbue);
&#125;;
</code></pre>
<p>æ‰€ä»¥æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œ<code>_IO_FILE_plus</code>çš„æ€»ä½“ç»“æ„å¦‚ä¸‹å›¾</p>
<p><img src="/img/article/fopen/t017448d9547dc07159-1669695992482-3.png" alt="img"></p>
<h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h2><p>è®©æˆ‘ä»¬å¤ç°ä¸€ä¸‹æ‰“å¼€ä¸€ä¸ªæ–‡ä»¶çš„è¿‡ç¨‹ï¼Œä»¥åŠ<code>_IO_FILE</code>ç»“æ„ä½“å¦‚ä½•åˆå§‹åŒ–ï¼Œfopençš„æºç å¦‚ä¸‹ï¼š</p>
<pre><code class="c">// https://elixir.bootlin.com/glibc/glibc-2.36/source/include/stdio.h#L191

extern FILE *_IO_new_fopen (const char*, const char*);
#   define fopen(fname, mode) _IO_new_fopen (fname, mode)

// https://elixir.bootlin.com/glibc/glibc-2.36/source/libio/iofopen.c#L83

FILE *
_IO_new_fopen (const char *filename, const char *mode)
&#123;
  return __fopen_internal (filename, mode, 1);
&#125;
</code></pre>
<p>å¯ä»¥çœ‹åˆ°åˆæ˜¯ä¸€ä¸ªå®ç„¶åï¼Œæºç å®é™…å®šä¹‰ä¸º<code>_IO_new_fopen</code>ã€‚</p>
<blockquote>
<p>çœŸçˆ±ç”Ÿå‘½ï¼Œè¿œç¦»å®å®šä¹‰</p>
</blockquote>
<p>ç„¶åå®ƒä¼šè°ƒç”¨<code>__fopen_internal</code>ï¼š</p>
<pre><code class="c">// https://elixir.bootlin.com/glibc/glibc-2.36/source/libio/iofopen.c#L56

FILE *
__fopen_internal (const char *filename, const char *mode, int is32)
&#123;
  struct locked_FILE
  &#123;
    struct _IO_FILE_plus fp;
#ifdef _IO_MTSAFE_IO
    _IO_lock_t lock;
#endif
    struct _IO_wide_data wd;
  &#125; *new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));

  if (new_f == NULL)
    return NULL;
#ifdef _IO_MTSAFE_IO
  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;
#endif
  _IO_no_init (&amp;new_f-&gt;fp.file, 0, 0, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);
  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;
  _IO_new_file_init_internal (&amp;new_f-&gt;fp);
  if (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != NULL)
    return __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);

  _IO_un_link (&amp;new_f-&gt;fp);
  free (new_f);
  return NULL;
&#125;
</code></pre>
<p>åœ¨è¿™ä¸ªå‡½æ•°ä¸­é¦–å…ˆé€šè¿‡mallocäº†ä¸€ä¸ª<code>locked_FILE</code>ç»“æ„ä½“ï¼Œå…¶ä¸­å°±åŒ…å«ç€<code>_IO_FILE_plus</code>ï¼Œå¹¶å°†æ•´ä¸ªç©ºé—´ç”±æŒ‡é’ˆ<strong>new_f</strong>æŒ‡å‘ã€‚<code>_IO_no_init</code>å’Œ<code>_IO_new_file_init_internal </code>å¯¹è™šè¡¨è¿›è¡Œäº†åˆå§‹åŒ–ã€‚</p>
<p>å…ˆæ¥çœ‹çœ‹<code>_IO_no_init</code>å‡½æ•°ï¼Œå¼€å¤´å°±è°ƒç”¨äº†<code>_IO_old_init</code></p>
<pre><code class="c">// https://elixir.bootlin.com/glibc/glibc-2.36/source/libio/genops.c#L561
void
_IO_no_init (FILE *fp, int flags, int orientation,
         struct _IO_wide_data *wd, const struct _IO_jump_t *jmp)
&#123;
  _IO_old_init (fp, flags);
  fp-&gt;_mode = orientation;
  if (orientation &gt;= 0)
    &#123;
      fp-&gt;_wide_data = wd;
      fp-&gt;_wide_data-&gt;_IO_buf_base = NULL;
      fp-&gt;_wide_data-&gt;_IO_buf_end = NULL;
      fp-&gt;_wide_data-&gt;_IO_read_base = NULL;
      fp-&gt;_wide_data-&gt;_IO_read_ptr = NULL;
      fp-&gt;_wide_data-&gt;_IO_read_end = NULL;
      fp-&gt;_wide_data-&gt;_IO_write_base = NULL;
      fp-&gt;_wide_data-&gt;_IO_write_ptr = NULL;
      fp-&gt;_wide_data-&gt;_IO_write_end = NULL;
      fp-&gt;_wide_data-&gt;_IO_save_base = NULL;
      fp-&gt;_wide_data-&gt;_IO_backup_base = NULL;
      fp-&gt;_wide_data-&gt;_IO_save_end = NULL;

      fp-&gt;_wide_data-&gt;_wide_vtable = jmp;
    &#125;
  else
    /* Cause predictable crash when a wide function is called on a byte
       stream.  */
    fp-&gt;_wide_data = (struct _IO_wide_data *) -1L;
  fp-&gt;_freeres_list = NULL;
&#125;



// https://elixir.bootlin.com/glibc/glibc-2.36/source/libio/genops.c#L530
void
_IO_old_init (FILE *fp, int flags)
&#123;
  fp-&gt;_flags = _IO_MAGIC|flags;
  fp-&gt;_flags2 = 0;
  if (stdio_needs_locking)
    fp-&gt;_flags2 |= _IO_FLAGS2_NEED_LOCK;
  fp-&gt;_IO_buf_base = NULL;
  fp-&gt;_IO_buf_end = NULL;
  fp-&gt;_IO_read_base = NULL;
  fp-&gt;_IO_read_ptr = NULL;
  fp-&gt;_IO_read_end = NULL;
  fp-&gt;_IO_write_base = NULL;
  fp-&gt;_IO_write_ptr = NULL;
  fp-&gt;_IO_write_end = NULL;
  fp-&gt;_chain = NULL; /* Not necessary. */
v
  fp-&gt;_IO_save_base = NULL;
  fp-&gt;_IO_backup_base = NULL;
  fp-&gt;_IO_save_end = NULL;
  fp-&gt;_markers = NULL;
  fp-&gt;_cur_column = 0;
#if _IO_JUMPS_OFFSET
  fp-&gt;_vtable_offset = 0;
#endif
#ifdef _IO_MTSAFE_IO
  if (fp-&gt;_lock != NULL)
    _IO_lock_init (*fp-&gt;_lock);
#endif
&#125;
</code></pre>
<blockquote>
<p><code>_IO_old_init</code>å‡½æ•°æœ‰ä¸¤ä¸ªé‡è½½ï¼Œä¸Šé¢è°ƒç”¨çš„æ˜¯2å‚æ•°ï¼Œå³<code>_IO_old_init (FILE *fp, int flags)</code>ï¼›å¦å¤–è¿˜æœ‰ä¸€ä¸ª5å‚æ•°<code>_IO_no_init (FILE *fp, int flags, int orientation,struct _IO_wide_data *wd, const struct _IO_jump_t *jmp)</code>ï¼Œæºç å°±å®šä¹‰åœ¨2å‚æ•°çš„åé¢</p>
</blockquote>
<p>å¯ä»¥çœ‹åˆ°ï¼Œé¦–å…ˆ<code>_IO_old_init</code>å¯¹<code>_IO_FILE</code>çš„ä¸»è¦å‡ ä¸ªæˆå‘˜å˜é‡è¿›è¡Œäº†åˆå§‹åŒ–ï¼Œç„¶åç”±<code>_IO_no_init</code>ä¼šæ ¹æ®ä¼ å…¥å‚æ•°<strong>orientation</strong>çš„å€¼å†³å®šæ˜¯å¦å¯¹<code>_wide_data</code>ç›¸å…³å€¼åšåˆå§‹åŒ–(åŒæ—¶éœ€æ³¨æ„åˆ°<code>fopen</code>æ˜¯ç›´æ¥å¸¸é‡0ä¼ å…¥ï¼Œæ‰€ä»¥æ˜¯å¿…å®šåˆå§‹åŒ–è¯¥åŒºåŸŸ)ã€‚</p>
<p>ç„¶åæ¥ä¸‹æ¥æ‰§è¡Œäº† <strong>_IO_JUMPS (&amp;new_f-&gt;fp) &#x3D;  &amp; _IO_file_jumps</strong>ï¼Œè¿™é‡Œçš„<code>_IO_JUMPS</code>å…¶å®å°±æ˜¯<strong>vtable</strong>æŒ‡é’ˆï¼Œè€Œ<code>_IO_FILE_jumps</code>å°±æ˜¯æˆ‘ä»¬ä¹‹å‰è°ˆåˆ°çš„è™šè¡¨ã€‚ç›¸å½“äºè®©<strong>vtable</strong>æŒ‡é’ˆæŒ‡å‘äº†<strong>è™šè¡¨</strong>ï¼Œ<code>_IO_JUMPS</code>å’Œ<code>_IO_FILE_jumps</code>æºç å¦‚ä¸‹ï¼š</p>
<pre><code class="c">// https://elixir.bootlin.com/glibc/glibc-2.36/source/libio/libioP.h#L98
#define _IO_JUMPS(THIS) (THIS)-&gt;vtable

// https://elixir.bootlin.com/glibc/glibc-2.36/source/libio/fileops.c#L1432
const struct _IO_jump_t _IO_file_jumps libio_vtable =
&#123;
  JUMP_INIT_DUMMY,
  JUMP_INIT(finish, _IO_file_finish),
  JUMP_INIT(overflow, _IO_file_overflow),
  JUMP_INIT(underflow, _IO_file_underflow),
  JUMP_INIT(uflow, _IO_default_uflow),
  JUMP_INIT(pbackfail, _IO_default_pbackfail),
  JUMP_INIT(xsputn, _IO_file_xsputn),
  JUMP_INIT(xsgetn, _IO_file_xsgetn),
  JUMP_INIT(seekoff, _IO_new_file_seekoff),
  JUMP_INIT(seekpos, _IO_default_seekpos),
  JUMP_INIT(setbuf, _IO_new_file_setbuf),
  JUMP_INIT(sync, _IO_new_file_sync),
  JUMP_INIT(doallocate, _IO_file_doallocate),
  JUMP_INIT(read, _IO_file_read),
  JUMP_INIT(write, _IO_new_file_write),
  JUMP_INIT(seek, _IO_file_seek),
  JUMP_INIT(close, _IO_file_close),
  JUMP_INIT(stat, _IO_file_stat),
  JUMP_INIT(showmanyc, _IO_default_showmanyc),
  JUMP_INIT(imbue, _IO_default_imbue)
&#125;;
</code></pre>
<p>æ¥ç€è°ƒç”¨äº†<code>_IO_new_file_init_internal</code>,æºç å¦‚ä¸‹:</p>
<pre><code class="c">// https://elixir.bootlin.com/glibc/glibc-2.36/source/libio/fileops.c#L105
void
_IO_new_file_init_internal (struct _IO_FILE_plus *fp)
&#123;
  /* POSIX.1 allows another file handle to be used to change the position
     of our file descriptor.  Hence we actually don&#39;t know the actual
     position before we do the first fseek (and until a following fflush). */
  fp-&gt;file._offset = _IO_pos_BAD;
  fp-&gt;file._flags |= CLOSED_FILEBUF_FLAGS;

  _IO_link_in (fp);
  fp-&gt;file._fileno = -1;
&#125;
</code></pre>
<p>å…¶ä¸­ï¼Œ<code>_IO_FILE</code>çš„<strong>flag</strong>è¢«è®¾ç½®<strong>CLOSED_FILEBUF_FLAGS</strong>ï¼Œå…·ä½“å«ä¹‰å¯çœ‹å¦‚ä¸‹å®šä¹‰ï¼š</p>
<pre><code class="c">// https://elixir.bootlin.com/glibc/glibc-2.36/source/libio/fileops.c#L100
#define CLOSED_FILEBUF_FLAGS \
  (_IO_IS_FILEBUF+_IO_NO_READS+_IO_NO_WRITES+_IO_TIED_PUT_GET)

// https://elixir.bootlin.com/glibc/glibc-2.36/source/libio/libio.h#L81
#define _IO_IS_FILEBUF        0x2000
// https://elixir.bootlin.com/glibc/glibc-2.36/source/libio/libio.h#L70
#define _IO_NO_READS          0x0004 /* Reading not allowed.  */
// https://elixir.bootlin.com/glibc/glibc-2.36/source/libio/libio.h#L71
#define _IO_NO_WRITES         0x0008 /* Writing not allowed.  */
// https://elixir.bootlin.com/glibc/glibc-2.36/source/libio/libio.h#L78
#define _IO_TIED_PUT_GET      0x0400 /* Put and get pointer move in unison.  */
</code></pre>
<p>éšåè°ƒç”¨äº†<code>_IO_link_in</code>ï¼Œé¦–å…ˆåˆ¤æ–­ <strong>_flags</strong>æ˜¯å¦å·²ç»è¢«linkè¿‡ã€‚å¦‚æœæ²¡æœ‰ï¼Œå°±å°† <strong>_chain</strong>èµ‹å€¼ä¸º <strong>_IO_list_all</strong>ã€‚å…¶å®å°±æ˜¯ä¸€ä¸ªä¸€ä¸ªå¾€å•é“¾è¡¨ä¸Šå¢æ·»èŠ‚ç‚¹ï¼Œä¸²è”äº†æ‰€æœ‰çš„<code>_IO_FILE_plus</code></p>
<blockquote>
<p><strong>_flags</strong>ç›¸å…³åˆ¤æ–­å’Œé™„åŠ ä¸»è¦é€šè¿‡ä½è¿ç®—å®ç°ï¼Œè¿™é‡Œä¸åšè¿™ç§ç¨‹åº¦çš„å…·ä½“è§£é‡Š(éƒ½å¼€å§‹ç ”ç©¶IO_FILEäº†ï¼Œæ€»ä¸èƒ½ä½è¿ç®—è¿˜æä¸æ˜ç™½å§)</p>
</blockquote>
<pre><code class="c">// https://elixir.bootlin.com/glibc/glibc-2.36/source/libio/genops.c#L86
void
_IO_link_in (struct _IO_FILE_plus *fp)
&#123;
  if ((fp-&gt;file._flags &amp; _IO_LINKED) == 0)
    &#123;
      fp-&gt;file._flags |= _IO_LINKED;
#ifdef _IO_MTSAFE_IO
      _IO_cleanup_region_start_noarg (flush_cleanup);
      _IO_lock_lock (list_all_lock);
      run_fp = (FILE *) fp;
      _IO_flockfile ((FILE *) fp);
#endif
      fp-&gt;file._chain = (FILE *) _IO_list_all;
      _IO_list_all = fp;
#ifdef _IO_MTSAFE_IO
      _IO_funlockfile ((FILE *) fp);
      run_fp = NULL;
      _IO_lock_unlock (list_all_lock);
      _IO_cleanup_region_end (0);
#endif
    &#125;
&#125;
libc_hidden_def (_IO_link_in)
</code></pre>
<p>åœ¨linkå®Œæˆåï¼Œå°±ä¼šæ¥ç€è°ƒç”¨<code>_IO_file_fopen</code>ï¼Œå®é™…å‡½æ•°å®šä¹‰çš„ä¸º<code> _IO_new_file_fopen</code></p>
<pre><code class="c">// https://elixir.bootlin.com/glibc/glibc-2.36/source/libio/fileops.c#L211

FILE *
_IO_new_file_fopen (FILE *fp, const char *filename, const char *mode,
            int is32not64)
&#123;
  int oflags = 0, omode;
  int read_write;
  int oprot = 0666;
  int i;
  FILE *result;
  const char *cs;
  const char *last_recognized;

  if (_IO_file_is_open (fp))
    return 0;
  switch (*mode)
    &#123;
    case &#39;r&#39;:
      omode = O_RDONLY;
      read_write = _IO_NO_WRITES;
      break;
    case &#39;w&#39;:
      omode = O_WRONLY;
      oflags = O_CREAT|O_TRUNC;
      read_write = _IO_NO_READS;
      break;
    case &#39;a&#39;:
      omode = O_WRONLY;
      oflags = O_CREAT|O_APPEND;
      read_write = _IO_NO_READS|_IO_IS_APPENDING;
      break;
    default:
      __set_errno (EINVAL);
      return NULL;
    &#125;
  last_recognized = mode;
  for (i = 1; i &lt; 7; ++i)
    &#123;
      switch (*++mode)
    &#123;
    case &#39;\0&#39;:
      break;
    case &#39;+&#39;:
      omode = O_RDWR;
      read_write &amp;= _IO_IS_APPENDING;
      last_recognized = mode;
      continue;
    case &#39;x&#39;:
      oflags |= O_EXCL;
      last_recognized = mode;
      continue;
    case &#39;b&#39;:
      last_recognized = mode;
      continue;
    case &#39;m&#39;:
      fp-&gt;_flags2 |= _IO_FLAGS2_MMAP;
      continue;
    case &#39;c&#39;:
      fp-&gt;_flags2 |= _IO_FLAGS2_NOTCANCEL;
      continue;
    case &#39;e&#39;:
      oflags |= O_CLOEXEC;
      fp-&gt;_flags2 |= _IO_FLAGS2_CLOEXEC;
      continue;
    default:
      /* Ignore.  */
      continue;
    &#125;
      break;
    &#125;

  result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write,
              is32not64);

  if (result != NULL)
    &#123;
      /* Test whether the mode string specifies the conversion.  */
      cs = strstr (last_recognized + 1, &quot;,ccs=&quot;);
      if (cs != NULL)
    &#123;
      /* Yep.  Load the appropriate conversions and set the orientation
         to wide.  */
      struct gconv_fcts fcts;
      struct _IO_codecvt *cc;
      char *endp = __strchrnul (cs + 5, &#39;,&#39;);
      char *ccs = malloc (endp - (cs + 5) + 3);

      if (ccs == NULL)
        &#123;
          int malloc_err = errno;  /* Whatever malloc failed with.  */
          (void) _IO_file_close_it (fp);
          __set_errno (malloc_err);
          return NULL;
        &#125;

      *((char *) __mempcpy (ccs, cs + 5, endp - (cs + 5))) = &#39;\0&#39;;
      strip (ccs, ccs);

      if (__wcsmbs_named_conv (&amp;fcts, ccs[2] == &#39;\0&#39;
                   ? upstr (ccs, cs + 5) : ccs) != 0)
        &#123;
          /* Something went wrong, we cannot load the conversion modules.
         This means we cannot proceed since the user explicitly asked
         for these.  */
          (void) _IO_file_close_it (fp);
          free (ccs);
          __set_errno (EINVAL);
          return NULL;
        &#125;

      free (ccs);

      assert (fcts.towc_nsteps == 1);
      assert (fcts.tomb_nsteps == 1);

      fp-&gt;_wide_data-&gt;_IO_read_ptr = fp-&gt;_wide_data-&gt;_IO_read_end;
      fp-&gt;_wide_data-&gt;_IO_write_ptr = fp-&gt;_wide_data-&gt;_IO_write_base;

      /* Clear the state.  We start all over again.  */
      memset (&amp;fp-&gt;_wide_data-&gt;_IO_state, &#39;\0&#39;, sizeof (__mbstate_t));
      memset (&amp;fp-&gt;_wide_data-&gt;_IO_last_state, &#39;\0&#39;, sizeof (__mbstate_t));

      cc = fp-&gt;_codecvt = &amp;fp-&gt;_wide_data-&gt;_codecvt;

      cc-&gt;__cd_in.step = fcts.towc;

      cc-&gt;__cd_in.step_data.__invocation_counter = 0;
      cc-&gt;__cd_in.step_data.__internal_use = 1;
      cc-&gt;__cd_in.step_data.__flags = __GCONV_IS_LAST;
      cc-&gt;__cd_in.step_data.__statep = &amp;result-&gt;_wide_data-&gt;_IO_state;

      cc-&gt;__cd_out.step = fcts.tomb;

      cc-&gt;__cd_out.step_data.__invocation_counter = 0;
      cc-&gt;__cd_out.step_data.__internal_use = 1;
      cc-&gt;__cd_out.step_data.__flags = __GCONV_IS_LAST | __GCONV_TRANSLIT;
      cc-&gt;__cd_out.step_data.__statep = &amp;result-&gt;_wide_data-&gt;_IO_state;

      /* From now on use the wide character callback functions.  */
      _IO_JUMPS_FILE_plus (fp) = fp-&gt;_wide_data-&gt;_wide_vtable;

      /* Set the mode now.  */
      result-&gt;_mode = 1;
    &#125;
    &#125;

  return result;
&#125;
libc_hidden_ver (_IO_new_file_fopen, _IO_file_fopen)
</code></pre>
<p>è¿™ä¸ªå‡½æ•°ï¼Œé¦–å…ˆæ£€æŸ¥äº†æ˜¯å¦æ­£å¸¸æ‰“å¼€æ–‡ä»¶ï¼Œç´§æ¥ç€å¯¹<strong>omode</strong>å’Œ<strong>oflags</strong>è¿›è¡Œäº†è®¾ç½®ï¼Œå³æ–‡ä»¶æƒé™ç›¸å…³è®¾ç½®ã€‚ç›´æ¥è¿›å…¥<code>_IO_file_open</code>æŸ¥çœ‹</p>
<pre><code class="c">// https://elixir.bootlin.com/glibc/glibc-2.36/source/libio/fileops.c#L180
FILE *
_IO_file_open (FILE *fp, const char *filename, int posix_mode, int prot,
           int read_write, int is32not64)
&#123;
  int fdesc;
  if (__glibc_unlikely (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL))
    fdesc = __open_nocancel (filename,
                 posix_mode | (is32not64 ? 0 : O_LARGEFILE), prot);
  else
    fdesc = __open (filename, posix_mode | (is32not64 ? 0 : O_LARGEFILE), prot);
  if (fdesc &lt; 0)
    return NULL;
  fp-&gt;_fileno = fdesc;
  _IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);
  /* For append mode, send the file offset to the end of the file.  Don&#39;t
     update the offset cache though, since the file handle is not active.  */
  if ((read_write &amp; (_IO_IS_APPENDING | _IO_NO_READS))
      == (_IO_IS_APPENDING | _IO_NO_READS))
    &#123;
      off64_t new_pos = _IO_SYSSEEK (fp, 0, _IO_seek_end);
      if (new_pos == _IO_pos_BAD &amp;&amp; errno != ESPIPE)
    &#123;
      __close_nocancel (fdesc);
      return NULL;
    &#125;
    &#125;
  _IO_link_in ((struct _IO_FILE_plus *) fp);
  return fp;
&#125;
libc_hidden_def (_IO_file_open)
</code></pre>
<p>é¦–å…ˆä¼šæ ¹æ®<strong>flag2</strong>å†³å®šè°ƒç”¨<code>__open_nocancel</code>æˆ–<code>open</code>ã€‚æ‰“å¼€æ–‡ä»¶ååˆ©ç”¨<code>_IO_mask_flags</code>é‡æ–°åˆå§‹åŒ–<strong>fp-&gt;flag</strong>,éšåè°ƒç”¨<code>_IO_link_in</code>åˆå§‹åŒ–chainåŸŸï¼Œä¸‹é¢æ˜¯<code>_IO_mask_flags</code>å’Œ<code>_IO_link_in</code>çš„æºç </p>
<pre><code class="c">// https://elixir.bootlin.com/glibc/glibc-2.36/source/libio/libioP.h#L518
#define _IO_mask_flags(fp, f, mask) \
       ((fp)-&gt;_flags = ((fp)-&gt;_flags &amp; ~(mask)) | ((f) &amp; (mask)))

// https://elixir.bootlin.com/glibc/glibc-2.36/source/libio/genops.c#L86
void
_IO_link_in (struct _IO_FILE_plus *fp)
&#123;
  if ((fp-&gt;file._flags &amp; _IO_LINKED) == 0)
    &#123;
      fp-&gt;file._flags |= _IO_LINKED;
#ifdef _IO_MTSAFE_IO
      _IO_cleanup_region_start_noarg (flush_cleanup);
      _IO_lock_lock (list_all_lock);
      run_fp = (FILE *) fp;
      _IO_flockfile ((FILE *) fp);
#endif
      fp-&gt;file._chain = (FILE *) _IO_list_all;
      _IO_list_all = fp;
#ifdef _IO_MTSAFE_IO
      _IO_funlockfile ((FILE *) fp);
      run_fp = NULL;
      _IO_lock_unlock (list_all_lock);
      _IO_cleanup_region_end (0);
#endif
    &#125;
&#125;
</code></pre>
<p>å›åˆ°<code>__fopen_internal</code>å‡½æ•°ä¸­ï¼Œå¯ä»¥çœ‹åˆ°æ¥ä¸‹æ¥è°ƒç”¨äº†<code>__fopen_maybe_mmap</code>ï¼Œç”±æ³¨é‡Šæˆ‘ä»¬å¯çŸ¥ï¼Œè¿™é‡Œæ˜¯æ ¹æ®æ–‡ä»¶çš„æƒé™ï¼Œåšä¸€äº›mmapçš„å¤„ç†ï¼Œç„¶åè¿”å›å³å¯ã€‚</p>
<pre><code class="c">// https://elixir.bootlin.com/glibc/glibc-2.36/source/libio/iofopen.c#L34
FILE *
__fopen_maybe_mmap (FILE *fp)
&#123;
#if _G_HAVE_MMAP
  if ((fp-&gt;_flags2 &amp; _IO_FLAGS2_MMAP) &amp;&amp; (fp-&gt;_flags &amp; _IO_NO_WRITES))
    &#123;
      /* Since this is read-only, we might be able to mmap the contents
     directly.  We delay the decision until the first read attempt by
     giving it a jump table containing functions that choose mmap or
     vanilla file operations and reset the jump table accordingly.  */

      if (fp-&gt;_mode &lt;= 0)
    _IO_JUMPS_FILE_plus (fp) = &amp;_IO_file_jumps_maybe_mmap;
      else
    _IO_JUMPS_FILE_plus (fp) = &amp;_IO_wfile_jumps_maybe_mmap;
      fp-&gt;_wide_data-&gt;_wide_vtable = &amp;_IO_wfile_jumps_maybe_mmap;
    &#125;
#endif
  return fp;
&#125;
</code></pre>
<p>ç„¶åè°ƒç”¨äº†<code>_IO_un_link</code>è¿›è¡Œå°†è¯¥æ–‡ä»¶è¿›è¡Œè§£é“¾æ“ä½œï¼Œéšåfreeæ‰ã€‚</p>
<pre><code class="c">// https://elixir.bootlin.com/glibc/glibc-2.36/source/libio/genops.c#L52
void
_IO_un_link (struct _IO_FILE_plus *fp)
&#123;
  if (fp-&gt;file._flags &amp; _IO_LINKED)
    &#123;
      FILE **f;
#ifdef _IO_MTSAFE_IO
      _IO_cleanup_region_start_noarg (flush_cleanup);
      _IO_lock_lock (list_all_lock);
      run_fp = (FILE *) fp;
      _IO_flockfile ((FILE *) fp);
#endif
      if (_IO_list_all == NULL)
    ;
      else if (fp == _IO_list_all)
    _IO_list_all = (struct _IO_FILE_plus *) _IO_list_all-&gt;file._chain;
      else
    for (f = &amp;_IO_list_all-&gt;file._chain; *f; f = &amp;(*f)-&gt;_chain)
      if (*f == (FILE *) fp)
        &#123;
          *f = fp-&gt;file._chain;
          break;
        &#125;
      fp-&gt;file._flags &amp;= ~_IO_LINKED;
#ifdef _IO_MTSAFE_IO
      _IO_funlockfile ((FILE *) fp);
      run_fp = NULL;
      _IO_lock_unlock (list_all_lock);
      _IO_cleanup_region_end (0);
#endif
    &#125;
&#125;
libc_hidden_def (_IO_un_link)
</code></pre>
<p>è¿™å°±æ˜¯fopençš„æ•´ä¸ªè¿‡ç¨‹äº†ï¼Œè¿™é‡Œæˆ‘ä»¬å°å°æ€»ç»“ä¸€ä¸‹æµç¨‹ï¼š</p>
<ul>
<li>é¦–å…ˆåˆ©ç”¨<code>malloc</code>åˆ›å»ºåŒ…å«<code>_IO_FILE_plus</code>å’Œ<code>_IO_wide_data</code>çš„<code>locked_FILE</code>ç»“æ„ä½“</li>
<li>æ¥ç€è°ƒç”¨<code>_IO_no_init</code>å‡½æ•°å¯¹<code>_IO_FILE</code>çš„ä¸»è¦å‡ ä¸ªæˆå‘˜å˜é‡è¿›è¡Œäº†åˆå§‹åŒ–ï¼Œä»¥åŠ<code>_wide_data</code>ç›¸å…³å€¼åšåˆå§‹åŒ–</li>
<li>èµ‹å€¼è™šè¡¨ç»™vtable</li>
<li>è°ƒç”¨<code>_IO_new_file_init_internal</code>è¿›ä¸€æ­¥åˆå§‹åŒ–ï¼Œä¸»è¦æ˜¯å¯¹**_chain**è¿›è¡Œæ“ä½œ</li>
<li>è°ƒç”¨<code>_IO_file_fopen</code>æ‰“å¼€æ–‡ä»¶</li>
<li>æ ¹æ®æ–‡ä»¶çš„æƒé™ï¼Œç”¨<code>__fopen_maybe_mmap</code>åšä¸€äº›å¯èƒ½çš„mmapæ“ä½œ</li>
<li>è„±ç¦»å•é“¾è¡¨é“¾</li>
<li>free</li>
</ul>

        </div>

    

</div>
                <div class="footer">
    <span>Copyright Â© 2022 Loora1N&#39;s Blog | é¹­é›¨</span>
    <span>Theme Designed By <a target="_blank" href="https://zheli.design/one-paper">é€™æè¨­è¨ˆ</a></span>
</div>


<link rel="stylesheet" href="/css/a11y-dark.min.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

            </div>
        </div>
    <!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?Loora1N";
            var git_color =['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'];
            var git_user ="Loora1N";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/about/'){
                console.log('å·²æŒ‚è½½github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // æ— æŠ¥é”™ï¼Œä½†ä¸å½±å“ä½¿ç”¨(æ”¯æŒpjaxè·³è½¬)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // æœ‰æŠ¥é”™ï¼Œä½†ä¸å½±å“ä½¿ç”¨(æ”¯æŒpjaxè·³è½¬)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><!-- hexo injector body_end end --></body>
</html>