<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Loora1N">



    <meta name="description" content="Blog of Loora1N">





<title>【fuzz】AFL白皮书中英双语版 | Loora1N&#39;s Blog | 鹭雨</title>



    <link rel="icon" href="/favicon.ico">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/menu.js"></script>
    
    <script src="/js/highlight.min.js"></script>
    
    <script src="/js/highlightjs-line-numbers.js"></script>
    
    <script src="/js/format.js"></script>
    
    <script src="/js/search.js"></script>
    







    <script src='https://unpkg.com/valine@1.4.16/dist/Valine.min.js'></script>




  <meta name="generator" content="Hexo 6.2.0"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">
          
            Loora1N&#39;s Blog | 鹭雨
          
        </a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/">首页</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/archives/">索引</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/about/">述己</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/links/">友链</a>
              </li> 
                   
          
          
            <li class="menu-item search-btn">
              <a href="#">Search</a>
            </li>
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
        </div>
        <div class="post-title">
            
            
                【fuzz】AFL白皮书中英双语版
            
            
        </div>
        <span class="post-date">
            8月 23, 2023
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>最近想研究研究AFL整体内部逻辑源码，面试时也遇到了同样的问题，决定从AFL白皮书开始看看。网上有很多翻译版，但是要不就是没写完，要不就是机翻痕迹太重。决定自己完成这个任务，争取在一周内完成大部分核心源码的分析。又想到之前看<a href="https://loora1n.github.io/2023/04/24/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%A4%8D%E4%B9%A0/">网络协议栈</a>和<a href="https://loora1n.github.io/2022/11/29/%E3%80%90IO_FILE%E3%80%91%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%A6%82%E8%A7%88/">IO_FILE</a>时的噩梦了😭😭😭</p>
</blockquote>
<p>本人英语水平有限，如有问题可以文末评论区直接指出。我想做中英双语版也是尽量在一定程度上防止大家被我的蹩脚翻译带偏。</p>
<p>白皮书的原文部分我都会使用markdown的引用语法，另外，全文使用AFL简写替代American fuzzy lop.</p>
<blockquote>
<p>AFL白皮书原文：<a target="_blank" rel="noopener" href="https://lcamtuf.coredump.cx/afl/technical_details.txt">lcamtuf.coredump.cx&#x2F;afl&#x2F;technical_details.txt</a></p>
<p>AFL项目地址：<a target="_blank" rel="noopener" href="https://github.com/google/AFL">google&#x2F;AFL: american fuzzy lop - a security-oriented fuzzer (github.com)</a></p>
<p>本文也部分参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cc7a486e5adb">翻译afl-fuzz白皮书 - 简书 (jianshu.com)</a></p>
</blockquote>
<h2 id="文档介绍"><a href="#文档介绍" class="headerlink" title="文档介绍"></a>文档介绍</h2><blockquote>
<p>This document provides a quick overview of the guts of American Fuzzy Lop. See README for the general instruction manual; and for a discussion of motivations and design goals behind AFL, see historical_notes.txt.</p>
</blockquote>
<p>本文档为AFL的内部结构提供了一个简要的概述。通用说明手册可以直接查阅README]部分，另外，有关AFL背后的设计目标和动机可以参阅hisrotical_notes.txt。</p>
<h2 id="0）Design-statement-设计说明"><a href="#0）Design-statement-设计说明" class="headerlink" title="0）Design statement 设计说明"></a>0）Design statement 设计说明</h2><blockquote>
<p>American Fuzzy Lop does its best not to focus on any singular principle of<br>operation and not be a proof-of-concept for any specific theory. The tool can<br>be thought of as a collection of hacks that have been tested in practice,<br>found to be surprisingly effective, and have been implemented in the simplest,<br>most robust way I could think of at the time</p>
</blockquote>
<p>AFL尽力不关注任何单一操作的原理，同时也不是任何特定理论的POC。这个工具可以看作是一个hack工具的集合，这些工具在实际的验证测试场景中非常有效，因此我用了那时我能想到的最简洁最具鲁棒性的方式实现设计了它。</p>
<blockquote>
<p>Many of the resulting features are made possible thanks to the availability of<br>lightweight instrumentation that served as a foundation for the tool, but this<br>mechanism should be thought of merely as a means to an end. The only true<br>governing principles are speed, reliability, and ease of use</p>
</blockquote>
<p>许多功能能够实现，都是多亏了将轻量化工具的可用性作为该项目的基础，但是这种机制应该仅仅被视作为了实现设计目的的一种手段。本项目真正的唯一的管理原则应是高效性、稳定性和易用性。</p>
<h2 id="1）Coverage-measurements-覆盖率测量"><a href="#1）Coverage-measurements-覆盖率测量" class="headerlink" title="1）Coverage measurements 覆盖率测量"></a>1）Coverage measurements 覆盖率测量</h2><blockquote>
<p>The instrumentation injected into compiled programs captures branch (edge)<br>coverage, along with coarse branch-taken hit counts. The code injected at<br>branch points is essentially equivalent to:</p>
</blockquote>
<p>通过向已编译程序注入检测代码来捕获代码分支（或边缘）的覆盖范围，同时粗略得记录分支命中计数。在分支点注入得代码本质上相当于如下伪代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;</span><br><span class="line">shared_mem[cur_location ^ prev_location]++; </span><br><span class="line">prev_location = cur_location &gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The cur_location value is generated randomly to simplify the process of<br>linking complex projects and keep the XOR output distributed uniformly.</p>
</blockquote>
<ul>
<li>cur_location 的值是随机生成的，以简化链接复杂项目的过程并保持 XOR 输出均匀分布。</li>
</ul>
<blockquote>
<p>The shared_mem[] array is a 64 kB SHM region passed to the instrumented binary<br>by the caller. Every byte set in the output map can be thought of as a hit for<br>a particular (branch_src, branch_dst) tuple in the instrumented code.</p>
</blockquote>
<ul>
<li>Shared_mem[] 数组是一个 64 kB SHM 区域，由调用者传递给已检测的二进制文件。输出映射中的每个字节集都可以被认为是检测代码中特定（branch_src，branch_dst）元组的命中。</li>
</ul>
<blockquote>
<p>The size of the map is chosen so that collisions are sporadic with almost all<br>of the intended targets, which usually sport between 2k and 10k discoverable<br>branch points:</p>
</blockquote>
<p>选择这个大小的映射，是为了统计几乎所有预测的目标的少量碰撞，而这些目标通常有2K到10K个可见的分支点：</p>
<table>
<thead>
<tr>
<th align="center">Branch cnt</th>
<th align="center">Colliding tuples</th>
<th align="center">Example targets</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1,000</td>
<td align="center">0.75%</td>
<td align="center">giflib, lzo</td>
</tr>
<tr>
<td align="center">2,000</td>
<td align="center">1.5%</td>
<td align="center">zlib, tar, xz</td>
</tr>
<tr>
<td align="center">5,000</td>
<td align="center">3.5%</td>
<td align="center">libpng, libwebp</td>
</tr>
<tr>
<td align="center">10,000</td>
<td align="center">7%</td>
<td align="center">libxml</td>
</tr>
<tr>
<td align="center">20,000</td>
<td align="center">14%</td>
<td align="center">sqlite</td>
</tr>
<tr>
<td align="center">50,000</td>
<td align="center">30%</td>
<td align="center">-</td>
</tr>
</tbody></table>
<blockquote>
<p>At the same time, its size is small enough to allow the map to be analyzed<br>in a matter of microseconds on the receiving end, and to effortlessly fit<br>within L2 cache.</p>
</blockquote>
<p>同时，由于他的size足够的小，得以允许接收端可以在几微秒的时间内分析映射，并将其放入二级缓存中。</p>
<blockquote>
<p>This form of coverage provides considerably more insight into the execution<br>path of the program than simple block coverage. In particular, it trivially<br>distinguishes between the following execution traces:</p>
</blockquote>
<p>与简单的块覆盖相比，这种形式的覆盖可以更深入地了解程序的执行路径。特别是它可以轻易地区分以下执行流程:</p>
<ul>
<li>A -&gt; B -&gt; C -&gt; D -&gt; E (tuples: AB, BC, CD, DE)</li>
<li>A -&gt; B -&gt; D -&gt; C -&gt; E (tuples: AB, BD, DC, CE)</li>
</ul>
<blockquote>
<p>This aids the discovery of subtle fault conditions in the underlying code,<br>because security vulnerabilities are more often associated with unexpected<br>or incorrect state transitions than with merely reaching a new basic block.</p>
</blockquote>
<p>这有助于发现底层代码中的微妙故障情况，因为安全漏洞通常与意外或不正确的状态转换相关，而不是仅仅与到达新的基本块相关。</p>
<blockquote>
<p>The reason for the shift operation in the last line of the pseudocode shown<br>earlier in this section is to preserve the directionality of tuples (without<br>this, A ^ B would be indistinguishable from B ^ A) and to retain the identity<br>of tight loops (otherwise, A ^ A would be obviously equal to B ^ B).</p>
</blockquote>
<p>本节前面所示的伪代码最后一行中进行移位操作的原因是为了保留元组的方向性（没有这个，A ^ B 将与 B ^ A 无法区分）并保留紧密循环的标识（否则, A ^ A 显然等于 B ^ B)。</p>
<p><em><del>题外话，我不知道为什么大家都喜欢把这个地方的移位翻译成左移，不论是翻译还是代码层面都不应该出现这种错误吧</del></em></p>
<blockquote>
<p>The absence of simple saturating arithmetic opcodes on Intel CPUs means that<br>the hit counters can sometimes wrap around to zero. Since this is a fairly<br>unlikely and localized event, it’s seen as an acceptable performance trade-off.</p>
</blockquote>
<p>英特尔 CPU 上缺乏简单的饱和算术操作码，这意味着命中计数器有时会回滚到零。由于这是一个相当不可能发生的局部事件，因此它被视为可接受的性能权衡。</p>
<h2 id="2）Detecting-new-behaviors-检测新行为"><a href="#2）Detecting-new-behaviors-检测新行为" class="headerlink" title="2）Detecting new behaviors 检测新行为"></a>2）Detecting new behaviors 检测新行为</h2><blockquote>
<p>The fuzzer maintains a global map of tuples seen in previous executions; this<br>data can be rapidly compared with individual traces and updated in just a couple<br>of dword- or qword-wide instructions and a simple loop.</p>
</blockquote>
<p>模糊器维护先前执行中看到的元组的全局映射；该数据可以快速与单独的迹线进行比较，并只需几个dword或qword的指令和一个简单的循环即可更新。</p>
<blockquote>
<p>When a mutated input produces an execution trace containing new tuples, the<br>corresponding input file is preserved and routed for additional processing<br>later on (see section #3). Inputs that do not trigger new local-scale state<br>transitions in the execution trace (i.e., produce no new tuples) are discarded,<br>even if their overall control flow sequence is unique.</p>
</blockquote>
<p>当变异的输入产生包含新元组的程序执行流时，相应的输入文件将被保留并以供稍后进行其他处理（请参阅第 #3 节）。在执行跟踪中，不触发新的局部规模状态转换（即不产生新元组）的输入将被丢弃，即使它们的总体控制流序列是唯一的</p>
<blockquote>
<p>This approach allows for a very fine-grained and long-term exploration of<br>program state while not having to perform any computationally intensive and<br>fragile global comparisons of complex execution traces, and while avoiding the<br>scourge of path explosion.</p>
</blockquote>
<p>这种方法允许对程序状态进行非常细粒度和长期的探索，而不必对复杂的执行跟踪执行任何计算密集型和脆弱的全局比较，同时避免路径爆炸的危害。</p>
<blockquote>
<p>To illustrate the properties of the algorithm, consider that the second trace<br>shown below would be considered substantially new because of the presence of<br>new tuples (CA, AE):</p>
</blockquote>
<p>为了说明该算法的属性，请考虑由于新元组（CA、AE）的存在，下面显示的第二条轨迹将被视为实质上是新的：</p>
<ul>
<li>#1:	A -&gt; B -&gt; C -&gt; D -&gt; E </li>
<li>#2:    A -&gt; B -&gt; C -&gt; A -&gt; E</li>
</ul>
<blockquote>
<p>At the same time, with #2 processed, the following pattern will not be seen<br>as unique, despite having a markedly different overall execution path:</p>
</blockquote>
<p>同时，若保存#2路径后，尽管下面的例子整体执行路径明显不同，但将不会被视为一个新的路径：</p>
<ul>
<li>#3:	A -&gt; B -&gt; C -&gt; A -&gt; B -&gt; C -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E</li>
</ul>
<blockquote>
<p>In addition to detecting new tuples, the fuzzer also considers coarse tuple<br>hit counts. These are divided into several buckets:</p>
</blockquote>
<p>除了检测新元组之外，模糊器还考虑粗元组命中计数。这些被分为几个buckets:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span><span class="number">-7</span>, <span class="number">8</span><span class="number">-15</span>, <span class="number">16</span><span class="number">-31</span>, <span class="number">32</span><span class="number">-27</span>, <span class="number">128</span>+</span><br></pre></td></tr></table></figure>

<blockquote>
<p>To some extent, the number of buckets is an implementation artifact: it allows<br>an in-place mapping of an 8-bit counter generated by the instrumentation to<br>an 8-position bitmap relied on by the fuzzer executable to keep track of the<br>already-seen execution counts for each tuple.</p>
</blockquote>
<p>从某种意义上讲，这些buckets的数量是一种执行工具：它允许将生成的 8 位计数器就地映射到fuzzer执行器所依赖的 8 位位图，以跟踪已经看到的数据每个元组的执行计数</p>
<blockquote>
<p>Changes within the range of a single bucket are ignored; transition from one<br>bucket to another is flagged as an interesting change in program control flow,<br>and is routed to the evolutionary process outlined in the section below.</p>
</blockquote>
<p>单个bucket范围内的变化会被忽略掉；然而元组从一个bucket到另一个bucket的转换会被标记为程序控制流中的一个有趣的变化，然后会被保存下来传递至下一轮的演化过程中去。</p>
<blockquote>
<p>The hit count behavior provides a way to distinguish between potentially<br>interesting control flow changes, such as a block of code being executed<br>twice when it was normally hit only once. At the same time, it is fairly<br>insensitive to empirically less notable changes, such as a loop going from<br>47 cycles to 48. The counters also provide some degree of “accidental”<br>immunity against tuple collisions in dense trace maps.</p>
</blockquote>
<p>命中计数行为提供了一种区分潜在的有趣的控制流变换的方法，例如，通常只命中一次的代码块被执行了两次。同时，它对通常经验上不太显着的变化相当不敏感，例如从 47 个周期变为 48 个周期的循环。计数器还提供一定程度的“意外”免疫力，防止密集流映射中的元组碰撞</p>
<blockquote>
<p>The execution is policed fairly heavily through memory and execution time<br>limits; by default, the timeout is set at 5x the initially-calibrated<br>execution speed, rounded up to 20 ms. The aggressive timeouts are meant to<br>prevent dramatic fuzzer performance degradation by descending into tarpits<br>that, say, improve coverage by 1% while being 100x slower; we pragmatically<br>reject them and hope that the fuzzer will find a less expensive way to reach<br>the same code. Empirical testing strongly suggests that more generous time<br>limits are not worth the cost.</p>
</blockquote>
<p>通过内存和执行时间对执行过程进行相当严格的限制；默认情况下，超时设置为初始校准执行速度的 5 倍，大约为 20 毫秒。激进的超时限制是为了，防止模糊器性能因陷入某种”陷阱“而急剧下降，例如，将覆盖率提高 1%，同时速度慢 100 倍；我们一定会拒绝这种方法，并希望fuzzer能够找到一种代价更低的方式的方法来达到相同的代码块。同时，实证检验也非常强烈地表明，更宽松的时间限制是不值得的。</p>
<h2 id="3）Evolving-the-input-queue-改进输入队列"><a href="#3）Evolving-the-input-queue-改进输入队列" class="headerlink" title="3）Evolving the input queue 改进输入队列"></a>3）Evolving the input queue 改进输入队列</h2><blockquote>
<p>Mutated test cases that produced new state transitions within the program are<br>added to the input queue and used as a starting point for future rounds of<br>fuzzing. They supplement, but do not automatically replace, existing finds.</p>
</blockquote>
<p>在程序中产生新状态转换的变异测试用例被添加到输入队列中，并用作未来几轮模糊测试的起点。它们补充但不会自动取代现有发现地路径。</p>
<blockquote>
<p>In contrast to more greedy genetic algorithms, this approach allows the tool<br>to progressively explore various disjoint and possibly mutually incompatible<br>features of the underlying data format, as shown in this image:</p>
</blockquote>
<p>与更贪婪的遗传算法相比，这种方法允许工具逐步探索各种不相交且可能相互不兼容地特征的底层数据格式，如下图所示:</p>
<p><img src="/img/article/fuzzdoc/afl_gzip.png" alt="afl"></p>
<p>这里讨论该算法结果的几个实际示例：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html">http://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html</a></li>
<li><a target="_blank" rel="noopener" href="http://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html">http://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html</a></li>
</ul>
<blockquote>
<p>The synthetic corpus produced by this process is essentially a compact<br>collection of “hmm, this does something new!” input files, and can be used to<br>seed any other testing processes down the line (for example, to manually<br>stress-test resource-intensive desktop apps).</p>
</blockquote>
<p>此过程生成的合成语料库本质上是，“嗯，多了一些新的东西！”这样的输入文件的紧凑集合，并且可用于为任何其他测试流程提供种子（例如，手动对资源密集型桌面应用程序进行压力测试）</p>
<blockquote>
<p>With this approach, the queue for most targets grows to somewhere between 1k<br>and 10k entries; approximately 10-30% of this is attributable to the discovery<br>of new tuples, and the remainder is associated with changes in hit counts</p>
</blockquote>
<p>通过这种方法，大多数目标的队列会增长到 1k 到 10k 条目之间；其中大约 10-30% 归因于新元组的发现，其余部分与命中计数的变化有关。</p>
<blockquote>
<p>The following table compares the relative ability to discover file syntax and<br>explore program states when using several different approaches to guided<br>fuzzing. The instrumented target was GNU patch 2.7.3 compiled with -O3 and<br>seeded with a dummy text file; the session consisted of a single pass over the<br>input queue with afl-fuzz:</p>
</blockquote>
<p>下表比较了使用几种不同方法进行引导模糊测试时发现文件语法和探索程序状态的相对能力。检测的目标是使用 -O3 编译的 GNU 补丁 2.7.3，并使用虚拟文本文件作为种子；该会话由 afl-fuzz 单次传递的输入队列组成：</p>
<table>
<thead>
<tr>
<th align="center">Fuzzer guidance strategy used</th>
<th align="center">Blocks reached</th>
<th align="center">Edges reached</th>
<th align="center">Edge hit cnt var</th>
<th align="center">Highest-coverage test case generated</th>
</tr>
</thead>
<tbody><tr>
<td align="center">(Initial file)</td>
<td align="center">156</td>
<td align="center">163</td>
<td align="center">1.00</td>
<td align="center">(none)</td>
</tr>
<tr>
<td align="center">Blind fuzzing S</td>
<td align="center">182</td>
<td align="center">205</td>
<td align="center">2.23</td>
<td align="center">First 2 B of RCS diff</td>
</tr>
<tr>
<td align="center">Blind fuzzing L</td>
<td align="center">228</td>
<td align="center">265</td>
<td align="center">2.23</td>
<td align="center">First 4 B of -c mode diff</td>
</tr>
<tr>
<td align="center">Block coverage</td>
<td align="center">855</td>
<td align="center">1,130</td>
<td align="center">1.57</td>
<td align="center">Almost-valid RCS diff</td>
</tr>
<tr>
<td align="center">Edge coverage</td>
<td align="center">1,452</td>
<td align="center">2,070</td>
<td align="center">2.18</td>
<td align="center">One-chunk -c mode diff</td>
</tr>
<tr>
<td align="center">AFL model</td>
<td align="center">1,765</td>
<td align="center">2,597</td>
<td align="center">4.99</td>
<td align="center">Four-chunk -c mode diff</td>
</tr>
</tbody></table>
<blockquote>
<p>The first entry for blind fuzzing (“S”) corresponds to executing just a single<br>round of testing; the second set of figures (“L”) shows the fuzzer running in a<br>loop for a number of execution cycles comparable with that of the instrumented<br>runs, which required more time to fully process the growing queue.</p>
</blockquote>
<p>blind fuzzing（“S”）的第一个条目对应于仅执行一轮测试；第二组图（“L”）显示模糊器在循环中运行的执行周期数与检测运行的运行周期相当，这需要更多时间来完全处理不断增长的队列。</p>
<blockquote>
<p>Roughly similar results have been obtained in a separate experiment where the<br>fuzzer was modified to compile out all the random fuzzing stages and leave just<br>a series of rudimentary, sequential operations such as walking bit flips.<br>Because this mode would be incapable of altering the size of the input file,<br>the sessions were seeded with a valid unified diff:</p>
</blockquote>
<p>在另一个实验中获得了大致相似的结果，其中模糊器被修改为编译出所有随机模糊阶段，只留下一系列基本的顺序操作，例如步行位翻转。由于此模式无法更改输入文件的大小，会话使用有效的统一差异设定种子：</p>
<table>
<thead>
<tr>
<th align="center">Queue extension strategy used</th>
<th align="center">Blocks reached</th>
<th align="center">Edages reached</th>
<th align="center">Edge hit cnt var</th>
<th align="center">Number of unique crashes found</th>
</tr>
</thead>
<tbody><tr>
<td align="center">(Initial file)</td>
<td align="center">624</td>
<td align="center">717</td>
<td align="center">1.00</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">Blind fuzzing</td>
<td align="center">1,101</td>
<td align="center">1,409</td>
<td align="center">1.60</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">Block coverage</td>
<td align="center">1,255</td>
<td align="center">1,649</td>
<td align="center">1.48</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">Edge coverage</td>
<td align="center">1,259</td>
<td align="center">1,734</td>
<td align="center">1.72</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">AFL model</td>
<td align="center">1,452</td>
<td align="center">2,040</td>
<td align="center">3.16</td>
<td align="center">1</td>
</tr>
</tbody></table>
<blockquote>
<p>At noted earlier on, some of the prior work on genetic fuzzing relied on<br>maintaining a single test case and evolving it to maximize coverage. At least<br>in the tests described above, this “greedy” approach appears to confer no<br>substantial benefits over blind fuzzing strategies.</p>
</blockquote>
<p>如前所述，之前的一些遗传模糊测试工作依赖于维护单个测试用例并对其进行改进以最大化覆盖范围。至少在上述测试中，这种“贪婪”方法似乎并没有比盲目模糊测试策略带来实质性的好处。</p>
<h2 id="4）Culling-the-corpus-语料库剔除"><a href="#4）Culling-the-corpus-语料库剔除" class="headerlink" title="4）Culling the corpus 语料库剔除"></a>4）Culling the corpus 语料库剔除</h2><blockquote>
<p>The progressive state exploration approach outlined above means that some of<br>the test cases synthesized later on in the game may have edge coverage that<br>is a strict superset of the coverage provided by their ancestors.</p>
</blockquote>
<p>上面概述的渐进状态探索方法意味着，在流程中稍后合成的一些测试用例可能具有边缘覆盖，这是其祖先提供的覆盖的严格超集。</p>
<blockquote>
<p>To optimize the fuzzing effort, AFL periodically re-evaluates the queue using a<br>fast algorithm that selects a smaller subset of test cases that still cover<br>every tuple seen so far, and whose characteristics make them particularly<br>favorable to the tool.</p>
</blockquote>
<p>为了优化模糊测试工作，AFL 使用快速算法定期重新评估队列，该算法选择较小的测试用例子集，这些测试用例仍然覆盖迄今为止看到的每个元组，并且其特征使它们特别适合该工具。</p>
<blockquote>
<p>The algorithm works by assigning every queue entry a score proportional to its<br>execution latency and file size; and then selecting lowest-scoring candidates<br>for each tuple.</p>
</blockquote>
<p>该算法的工作原理是为每个队列条目分配与其执行延迟和文件大小成比例的分数;然后为每个元组选择得分最低的候选项。</p>
<blockquote>
<p>The tuples are then processed sequentially using a simple workflow:</p>
<ol>
<li>Find next tuple not yet in the temporary working set,</li>
<li>Locate the winning queue entry for this tuple,</li>
<li>Register <strong>all</strong> tuples present in that entry’s trace in the working set,</li>
<li>Go to #1 if there are any missing tuples in the set.</li>
</ol>
</blockquote>
<p>然后使用一种简易的流程处理这些元组：</p>
<ol>
<li>找到一个未在临时工作集中的元组</li>
<li>找到这个元组的winning队列条目</li>
<li>在工作集中注册该条目的<strong>所有</strong>存在的元组</li>
<li>如果在集合里有任何缺少的元组，返回流程1</li>
</ol>
<blockquote>
<p>The generated corpus of “favored” entries is usually 5-10x smaller than the<br>starting data set. Non-favored entries are not discarded, but they are skipped<br>with varying probabilities when encountered in the queue:</p>
<ul>
<li><p>If there are new, yet-to-be-fuzzed favorites present in the queue, 99% of non-favored entries will be skipped to get to the favored ones.</p>
</li>
<li><p>If there are no new favorites:</p>
<ul>
<li><p>If the current non-favored entry was fuzzed before, it will be skipped 95% of the time.</p>
</li>
<li><p>If it hasn’t gone through any fuzzing rounds yet, the odds of skipping drop down to 75%.</p>
</li>
</ul>
</li>
</ul>
<p>Based on empirical testing, this provides a reasonable balance between queue </p>
<p>cycling speed and test case diversity.</p>
</blockquote>
<p>生成的”首选”的语料库通常比其实数据集要小 5-10 倍。不受欢迎的条目不会被丢弃，但它们在队列中会以不同概率被跳过：</p>
<ul>
<li>如果队列中存在新的、尚未被fuzz的<strong>favorites</strong>，则99%的<strong>non-favored</strong>条目将被跳过，而去访问<strong>favored</strong>条目</li>
<li>如果不存在新的<strong>favorites</strong>：<ul>
<li>如果当前<strong>non-favored</strong>条目之前被fuzz过，则有95%的几率跳过</li>
<li>如果当前<strong>non-favored</strong>条目未被fuzz过，则跳过的几率下降到75%</li>
</ul>
</li>
</ul>
<p>基于实际测试，这种方式在循环速度和测试用例多样性之间提供了合理的平衡</p>
<blockquote>
<p>Slightly more sophisticated but much slower culling can be performed on input<br>or output corpora with afl-cmin. This tool permanently discards the redundant<br>entries and produces a smaller corpus suitable for use with afl-fuzz or<br>external tools.</p>
</blockquote>
<p>可以使用 afl-cmin 对输入或输出语料库执行稍微复杂但速度慢得多的剔除。此工具会永久丢弃冗余条目，并生成适合与 afl-fuzz 或外部工具一起使用的较小语料库。</p>
<h2 id="5）Trimming-input-files-修剪输入文件"><a href="#5）Trimming-input-files-修剪输入文件" class="headerlink" title="5）Trimming input files 修剪输入文件"></a>5）Trimming input files 修剪输入文件</h2><blockquote>
<p>File size has a dramatic impact on fuzzing performance, both because large<br>files make the target binary slower, and because they reduce the likelihood<br>that a mutation would touch important format control structures, rather than<br>redundant data blocks. This is discussed in more detail in perf_tips.txt.</p>
</blockquote>
<p>文件大小对模糊测试性能有显著影响，这既是因为大文件会使目标二进制文件变慢，也是因为它们降低了突变接触重要格式控制结构的可能性，增大了接触冗余数据块的可能性。在perf_tips.txt中将对此问题做更详细地讨论。</p>
<blockquote>
<p>The possibility that the user will provide a low-quality starting corpus aside,<br>some types of mutations can have the effect of iteratively increasing the size<br>of the generated files, so it is important to counter this trend.</p>
</blockquote>
<p>就算不考虑用户自身提供低质量起始语料库的可能性，某些类型的突变也可能会导致迭代地增加生成文件的大小，因此扭转这种变化趋势非常重要。</p>
<blockquote>
<p>Luckily, the instrumentation feedback provides a simple way to automatically<br>trim down input files while ensuring that the changes made to the files have no<br>impact on the execution path.</p>
</blockquote>
<p>幸运的是，检测反馈提供了一种简单的方法来自动修剪输入文件，同时确保对文件所做的更改不会影响执行路径。</p>
<blockquote>
<p>The built-in trimmer in afl-fuzz attempts to sequentially remove blocks of data<br>with variable length and stepover; any deletion that doesn’t affect the checksum<br>of the trace map is committed to disk. The trimmer is not designed to be<br>particularly thorough; instead, it tries to strike a balance between precision<br>and the number of execve() calls spent on the process, selecting the block size<br>and stepover to match. The average per-file gains are around 5-20%.</p>
</blockquote>
<p>afl-fuzz 中的内置修剪器尝试按顺序删除具有可变长度和跨距的数据块;任何不影响跟踪映射校验和的删除都将提交到磁盘。修剪器的设计不是特别彻底；相反，通过选择匹配数据块大小和跨步大小，它试图在精度和进程<code>execve()</code>调用的数量上取得平衡。每个文件的平均收益为5-20%。</p>
<blockquote>
<p>The standalone afl-tmin tool uses a more exhaustive, iterative algorithm, and<br>also attempts to perform alphabet normalization on the trimmed files. The<br>operation of afl-tmin is as follows.</p>
</blockquote>
<p>独立的 afl-tmin 工具使用更详尽的迭代算法，并且还尝试对修剪后的文件执行字母规范化。afl-tmin的操作如下。</p>
<blockquote>
<p>First, the tool automatically selects the operating mode. If the initial input<br>crashes the target binary, afl-tmin will run in non-instrumented mode, simply<br>keeping any tweaks that produce a simpler file but still crash the target. If<br>the target is non-crashing, the tool uses an instrumented mode and keeps only<br>the tweaks that produce exactly the same execution path.</p>
</blockquote>
<p>首先，该工具会自动选择操作模式。如果初始输入使目标二进制文件崩溃，afl-tmin 将以非检测模式运行，只需保留生成更简单文件但仍会使目标崩溃的任何调整。如果目标未崩溃，则该工具使用检测模式，并仅保留生成完全相同执行路径的调整。</p>
<blockquote>
<p>The actual minimization algorithm is:</p>
<ol>
<li>Attempt to zero large blocks of data with large stepovers. Empirically, this is shown to reduce the number of execs by preempting finer-grained efforts later on.</li>
<li>Perform a block deletion pass with decreasing block sizes and stepovers, binary-search-style.</li>
<li>Perform a block deletion pass with decreasing block sizes and stepovers, binary-search-style.</li>
<li>Perform a block deletion pass with decreasing block sizes and stepovers, binary-search-style.</li>
</ol>
</blockquote>
<p>实际的最小化算法是：</p>
<ol>
<li>尝试将具有大跨距的大数据块归零。从经验上讲，这可以通过抢占以后更细粒度的工作来减少<code>exec</code>的数量。</li>
<li>以递减的块大小和步距执行块删除过程，采用二分搜索方式。</li>
<li>通过计算唯一字符并尝试将每个字符批量替换为零值来执行字母规范化。</li>
<li>最后，对非零字节执行逐字节归一化。</li>
</ol>
<blockquote>
<p>Instead of zeroing with a 0x00 byte, afl-tmin uses the ASCII digit ‘0’. This<br>is done because such a modification is much less likely to interfere with<br>text parsing, so it is more likely to result in successful minimization of<br>text files.</p>
</blockquote>
<p>afl-tmin 使用 ASCII 数字“0”，而不是使用 0x00 字节进行清零。这样做是因为这样的修改不太可能干扰文本解析，因此更有可能成功最小化文本文件。</p>
<blockquote>
<p>The algorithm used here is less involved than some other test case<br>minimization approaches proposed in academic work, but requires far fewer<br>executions and tends to produce comparable results in most real-world<br>applications.</p>
</blockquote>
<p>这里使用的算法比学术工作中提出的其他一些测试用例最小化方法涉及的程度要少，但需要的执行次数要少得多，并且往往会在大多数实际应用中产生可比较的结果。</p>
<h2 id="6）-Fuzzing-strategies-模糊测试策略"><a href="#6）-Fuzzing-strategies-模糊测试策略" class="headerlink" title="6） Fuzzing strategies 模糊测试策略"></a>6） Fuzzing strategies 模糊测试策略</h2><blockquote>
<p>The feedback provided by the instrumentation makes it easy to understand the<br>value of various fuzzing strategies and optimize their parameters so that they<br>work equally well across a wide range of file types. The strategies used by<br>afl-fuzz are generally format-agnostic and are discussed in more detail here:<br><a target="_blank" rel="noopener" href="http://lcamtuf.blogspot.com/2014/08/binary-fuzzing-strategies-what-works.html">http://lcamtuf.blogspot.com/2014/08/binary-fuzzing-strategies-what-works.html</a></p>
</blockquote>
<p>仪器提供的反馈使您可以轻松了解各种模糊测试策略的价值并优化其参数，以便它们在各种文件类型上同样有效。 afl-fuzz 使用的策略通常与格式无关，这里更详细地讨论:<br><a target="_blank" rel="noopener" href="http://lcamtuf.blogspot.com/2014/08/binary-fuzzing-strategies-what-works.html">http://lcamtuf.blogspot.com/2014/08/binary-fuzzing-strategies-what-works.html</a></p>
<blockquote>
<p>It is somewhat notable that especially early on, most of the work done by<br>afl-fuzz is actually highly deterministic, and progresses to random stacked<br>modifications and test case splicing only at a later stage. The deterministic<br>strategies include:</p>
</blockquote>
<ul>
<li>Sequential bit flips with varying lengths and stepovers,</li>
<li>Sequential addition and subtraction of small integers,</li>
<li>Sequential addition and subtraction of small integers,</li>
</ul>
<p>值得注意的是，特别是在早期，afl-fuzz 所做的大部分工作实际上是高度确定性的，并且仅在后期阶段才会进展到随机堆叠修改和测试用例拼接。确定性策略包括：</p>
<ul>
<li>顺序对不同长度和步距的位进行反转</li>
<li>顺序对小整数的加减法</li>
<li>顺序插入已知的interesting整数（0、1、INT_MAX等）</li>
</ul>
<blockquote>
<p>The purpose of opening with deterministic steps is related to their tendency to<br>produce compact test cases and small diffs between the non-crashing and crashing<br>inputs.</p>
</blockquote>
<p>以确定性步骤打开的目的与它们生成紧凑测试用例以及非崩溃和崩溃输入之间的小差异的倾向有关。</p>
<blockquote>
<p>With deterministic fuzzing out of the way, the non-deterministic steps include<br>stacked bit flips, insertions, deletions, arithmetics, and splicing of different<br>test cases.</p>
</blockquote>
<p>介绍完确定性模糊测试步骤，非确定性步骤包括堆叠位翻转、插入、删除、算术和不同测试用例的拼接。</p>
<blockquote>
<p>The relative yields and execve() costs of all these strategies have been<br>investigated and are discussed in the aforementioned blog post.</p>
</blockquote>
<p>所有这些策略的相对收益率和 <code>execve()</code>的成本都已在上述博客文章中进行了研究和讨论。</p>
<blockquote>
<p>For the reasons discussed in historical_notes.txt (chiefly, performance,<br>simplicity, and reliability), AFL generally does not try to reason about the<br>relationship between specific mutations and program states; the fuzzing steps<br>are nominally blind, and are guided only by the evolutionary design of the<br>input queue.</p>
</blockquote>
<p>正如 Historical_notes.txt 中讨论的原因（主要是性能、简单性和可靠性），AFL 通常不会尝试推理特定突变和程序状态之间的关系；模糊测试步骤名义上是盲目的，并且仅受输入队列的进化设计的指导。</p>
<blockquote>
<p>That said, there is one (trivial) exception to this rule: when a new queue<br>entry goes through the initial set of deterministic fuzzing steps, and tweaks to<br>some regions in the file are observed to have no effect on the checksum of the<br>execution path, they may be excluded from the remaining phases of<br>deterministic fuzzing - and the fuzzer may proceed straight to random tweaks.<br>Especially for verbose, human-readable data formats, this can reduce the number<br>of execs by 10-40% or so without an appreciable drop in coverage. In extreme<br>cases, such as normally block-aligned tar archives, the gains can be as high as<br>90%.</p>
</blockquote>
<p>也就是说，此规则有一个（微不足道的）例外：当新队列条目经历初始的一组确定性模糊步骤时，观察到对文件中某些区域的调整对执行路径的校验和没有影响，它们可能会被排除在确定性模糊测试的剩余阶段之外 - 并且模糊器可能会直接进行随机调整。特别是对于冗长的、人类可读的数据格式，这可以将执行数量减少 10-40% 左右，而覆盖率不会明显下降。在极端情况下，例如通常块对齐的 tar 存档，增益可高达 90%。</p>
<blockquote>
<p>Because the underlying “effector maps” are local every queue entry and remain<br>in force only during deterministic stages that do not alter the size or the<br>general layout of the underlying file, this mechanism appears to work very<br>reliably and proved to be simple to implement.</p>
</blockquote>
<p>由于底层“效应器映射”是每个队列条目的本地信息，并且仅在不改变底层文件的大小或总体布局的确定性阶段保持有效，因此该机制似乎工作非常可靠，并且被证明易于实现。</p>
<h2 id="7）Dictionaries-字典"><a href="#7）Dictionaries-字典" class="headerlink" title="7）Dictionaries 字典"></a>7）Dictionaries 字典</h2><blockquote>
<p>The feedback provided by the instrumentation makes it easy to automatically<br>identify syntax tokens in some types of input files, and to detect that certain<br>combinations of predefined or auto-detected dictionary terms constitute a<br>valid grammar for the tested parser.</p>
</blockquote>
<p>仪器提供的反馈使得自动识别某些类型的输入文件中的语法标记变得容易，并检测预定义或自动检测的字典术语的某些组合是否构成了测试解析器的有效语法。</p>
<p>有关如何在 afl-fuzz 中实现这些功能的讨论可以在此处找到:<br><a target="_blank" rel="noopener" href="http://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html">http://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html</a></p>
<blockquote>
<p>In essence, when basic, typically easily-obtained syntax tokens are combined<br>together in a purely random manner, the instrumentation and the evolutionary<br>design of the queue together provide a feedback mechanism to differentiate<br>between meaningless mutations and ones that trigger new behaviors in the<br>instrumented code - and to incrementally build more complex syntax on top of<br>this discovery.</p>
</blockquote>
<p>本质上，当基本的、通常容易获得的语法标记以纯粹随机的方式组合在一起时，队列的检测和进化设计一起提供了一种反馈机制，以区分无意义的突变和在检测代码中触发新行为的突变- 并在此发现的基础上逐步构建更复杂的语法。</p>
<blockquote>
<p>The dictionaries have been shown to enable the fuzzer to rapidly reconstruct<br>the grammar of highly verbose and complex languages such as JavaScript, SQL,<br>or XML; several examples of generated SQL statements are given in the blog<br>post mentioned above.</p>
</blockquote>
<p>事实证明，字典可以使模糊器快速重建高度冗长和复杂的语言（例如 JavaScript、SQL 或 XML）的语法；上面提到的博客文章中给出了生成 SQL 语句的几个示例。</p>
<blockquote>
<p>Interestingly, the AFL instrumentation also allows the fuzzer to automatically<br>isolate syntax tokens already present in an input file. It can do so by looking<br>for run of bytes that, when flipped, produce a consistent change to the<br>program’s execution path; this is suggestive of an underlying atomic comparison<br>to a predefined value baked into the code. The fuzzer relies on this signal<br>to build compact “auto dictionaries” that are then used in conjunction with<br>other fuzzing strategies.</p>
</blockquote>
<p>有趣的是，AFL 检测还允许模糊器自动隔离输入文件中已存在的语法标记。它可以通过查找字节运行来实现这一点，这些字节在翻转时会对程序的执行路径产生一致的更改；这表明代码中预定义值存在底层原子化的比较。模糊器依靠这个信号来构建紧凑的“自动字典”，然后与其他模糊策略结合使用。</p>
<h2 id="8）De-duping-crashes-重复数据删除崩溃"><a href="#8）De-duping-crashes-重复数据删除崩溃" class="headerlink" title="8）De-duping crashes 重复数据删除崩溃"></a>8）De-duping crashes 重复数据删除崩溃</h2><blockquote>
<p>De-duplication of crashes is one of the more important problems for any<br>competent fuzzing tool. Many of the naive approaches run into problems; in<br>particular, looking just at the faulting address may lead to completely<br>unrelated issues being clustered together if the fault happens in a common<br>library function (say, strcmp, strcpy); while checksumming call stack<br>backtraces can lead to extreme crash count inflation if the fault can be<br>reached through a number of different, possibly recursive code paths.</p>
</blockquote>
<p>对于任何有能力的模糊测试工具来说，如何删除重复数据是最重要的问题之一。许多简单的方法都会遇到问题。尤其是，如果故障发生在公共库函数（例如 strcmp、strcpy）中，则仅查看故障地址可能会导致完全不相关的问题聚集在一起；如果可以通过许多不同的、可能是递归的代码路径到达故障，则对调用堆栈回溯进行校验和可能会导致大量异常的崩溃计数。</p>
<blockquote>
<p>The solution implemented in afl-fuzz considers a crash unique if any of two<br>conditions are met:</p>
<ul>
<li>The crash trace includes a tuple not seen in any of the previous crashes,</li>
<li>The crash trace is missing a tuple that was always present in earlier faults.<br>如果满足下列两个条件的任意一种，afl-fuzz中实现的解决方案就会将其认定为一种crash</li>
</ul>
</blockquote>
<ul>
<li>若这个crash包含一个从未在其他crash中出现过的元组</li>
<li>若这个crash不包含一个总是在其他crash中出现的元组</li>
</ul>
<blockquote>
<p>The approach is vulnerable to some path count inflation early on, but exhibits<br>a very strong self-limiting effect, similar to the execution path analysis<br>logic that is the cornerstone of afl-fuzz.</p>
</blockquote>
<p>该方法早期容易受到路径计数膨胀的影响，但其表现出非常强的自我限制效应，同样体现在 afl-fuzz 基石的执行路径分析逻辑。</p>
<h2 id="9）Investigating-crashes-调查崩溃"><a href="#9）Investigating-crashes-调查崩溃" class="headerlink" title="9）Investigating crashes 调查崩溃"></a>9）Investigating crashes 调查崩溃</h2><blockquote>
<p>The exploitability of many types of crashes can be ambiguous; afl-fuzz tries<br>to address this by providing a crash exploration mode where a known-faulting<br>test case is fuzzed in a manner very similar to the normal operation of the<br>fuzzer, but with a constraint that causes any non-crashing mutations to be<br>thrown away.</p>
</blockquote>
<p>许多类型的崩溃的可利用性可能是不明确的； afl-fuzz 试图通过提供崩溃探索模式来解决这个问题，其中已知故障的测试用例以与模糊器正常操作非常相似的方式进行模糊测试，但有一个约束，导致任何非崩溃的突变都被丢弃。</p>
<p>有关此方法价值的详细讨论可以在此处找到</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://lcamtuf.blogspot.com/2014/11/afl-fuzz-crash-exploration-mode.html">http://lcamtuf.blogspot.com/2014/11/afl-fuzz-crash-exploration-mode.html</a></li>
</ul>
<blockquote>
<p>The method uses instrumentation feedback to explore the state of the crashing<br>program to get past the ambiguous faulting condition and then isolate the<br>newly-found inputs for human review.</p>
</blockquote>
<p>该方法使用仪器反馈来探索崩溃程序的状态，以克服模糊的故障条件，然后隔离新发现的输入以供人工审查。</p>
<blockquote>
<p>On the subject of crashes, it is worth noting that in contrast to normal<br>queue entries, crashing inputs are <em>not</em> trimmed; they are kept exactly as<br>discovered to make it easier to compare them to the parent, non-crashing entry<br>in the queue. That said, afl-tmin can be used to shrink them at will.</p>
</blockquote>
<p>关于崩溃问题，值得注意的是，与正常队列条目相比，崩溃输入<strong>不会</strong>被修剪；它们完全按照发现的方式保存，以便更容易将它们与队列中的父非崩溃条目进行比较。也就是说，afl-tmin 可以用来随意缩小它们。</p>
<h2 id="10）The-fork-server"><a href="#10）The-fork-server" class="headerlink" title="10）The fork server"></a>10）The fork server</h2><blockquote>
<p>To improve performance, afl-fuzz uses a “fork server”, where the fuzzed process<br>goes through execve(), linking, and libc initialization only once, and is then<br>cloned from a stopped process image by leveraging copy-on-write. The<br>implementation is described in more detail here:</p>
</blockquote>
<p>为了提高性能，afl-fuzz 使用<strong>“fork server”</strong>，其中模糊化进程仅执行一次 execve()、链接和 libc 初始化，然后通过利用<strong>copy-on-write</strong>从停止的进程映像进行克隆。这里更详细地描述了该实现：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html">http://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html</a></li>
</ul>
<blockquote>
<p>The fork server is an integral aspect of the injected instrumentation and<br>simply stops at the first instrumented function to await commands from<br>afl-fuzz.</p>
</blockquote>
<p>fork server是注入检测的一个组成部分，它只是在第一个检测函数处停止以等待来自 afl-fuzz 的命令。</p>
<blockquote>
<p>With fast targets, the fork server can offer considerable performance gains,<br>usually between 1.5x and 2x. It is also possible to:</p>
<ul>
<li>Use the fork server in manual (“deferred”) mode, skipping over larger, user-selected chunks of initialization code. It requires very modest code changes to the targeted program, and With some targets, can produce 10x+ performance gains.</li>
<li>Enable “persistent” mode, where a single process is used to try out multiple inputs, greatly limiting the overhead of repetitive fork() calls. This generally requires some code changes to the targeted program, but can improve the performance of fast targets by a factor of 5 or more - approximating the benefits of in-process fuzzing jobs while still maintaining very robust isolation between the fuzzer process and the targeted binary.</li>
</ul>
</blockquote>
<p>对于fast目标，fork server可以提供相当大的性能提升，通常在1.5倍到2倍之间。还可以：</p>
<ul>
<li>在手动的（“deferred”）模式下使用fork server，跳过较大的、用户选择的初始化代码块。它需要对目标程序进行恰到好处的代码更改，并且对于某些目标，可以产生10倍以上的性能提升</li>
<li>启用“persistent”模式，其中单个进程用于尝试多个输入，极大的限制了重复<code>fork()</code>调用的开销。这通常需要对目标程序进行一些代码更改，大可以将fast目标的性能提高5倍或者更多 - 近似于进程内模糊测试作业的好处，同时仍然保持fuzzer进程和目标二进制文件之间巨大的隔离。</li>
</ul>
<h2 id="其他部分"><a href="#其他部分" class="headerlink" title="其他部分"></a>其他部分</h2><p>剩下3章感觉不是很重要，可以自己去看看。之后有空再补上这部分吧</p>

</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
                <div class="icon arrow-left"></div>
                <div class="post-link">
                    <a href="/2023/08/29/ASAN%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">Prev</a>
                </div>
            
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2023/08/22/%E3%80%90fuzz%20trick%E3%80%91%E5%88%A9%E7%94%A8LCOV%E6%B5%8B%E9%87%8F%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

    
      <div class="post-comment">

    
        <div id="vcomments"></div>
        <script>
            var META = ['nick', 'mail', 'link'];
            var meta = 'nick,mail';
            meta = meta.split(',').filter(item => {
                return META.includes(item);
            });
            new Valine({
                el: '#vcomments',
                appId: 'rb5WOYmmPvNLWkXLJIiqi1p0-gzGzoHsz',
                appKey: 'B0j55vucTVteHiiUJeIL8Vx8',
                lang: 'zh-CN',
                placeholder: '这里是评论区:)',
                avatar: 'mp',
                meta: meta
            })
        </script>    
     

     
    
    

</div>
     
  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
            
            
                Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/zoeingwingkei/frame/">Frame</a>
                
        </div>
    </div>
</div>

    </div>

    
      <div class="search-popup">
    <div class="search-popup-overlay">  
    </div>
    <div class="search-popup-window" >
        <div class="search-header">
            <div class="search-input-container">
              <input autocomplete="off" autocapitalize="off" maxlength="80"
                     placeholder="Search Anything" spellcheck="false"
                     type="search" class="search-input">
            </div>
            <div class="search-close-btn">
                <div class="icon close-btn"></div>
            </div>
        </div>
        <div class="search-result-container">
        </div>
    </div>
</div>

<script>
    const searchConfig = {
        path             : "/search.xml",
        top_n_per_article: "1",
        unescape         : "false",
        trigger: "auto",
        preload: "false"
    }
</script>
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js"></script>
<script src="/js/search.js"></script>
    
    

  <!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?Loora1N";
            var git_color =['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'];
            var git_user ="Loora1N";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/about/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><!-- hexo injector body_end end --></body>
</html>
