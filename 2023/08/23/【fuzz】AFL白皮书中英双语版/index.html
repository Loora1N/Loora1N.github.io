<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Loora1N">



    <meta name="description" content="Blog of Loora1N">





<title>ã€fuzzã€‘AFLç™½çš®ä¹¦ä¸­è‹±åŒè¯­ç‰ˆ | Loora1N&#39;s Blog | é¹­é›¨</title>



    <link rel="icon" href="/favicon.ico">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/menu.js"></script>
    
    <script src="/js/highlight.min.js"></script>
    
    <script src="/js/highlightjs-line-numbers.js"></script>
    
    <script src="/js/format.js"></script>
    
    <script src="/js/search.js"></script>
    







    <script src='https://unpkg.com/valine@1.4.16/dist/Valine.min.js'></script>




  <meta name="generator" content="Hexo 6.2.0"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">
          
            Loora1N&#39;s Blog | é¹­é›¨
          
        </a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/">é¦–é¡µ</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/archives/">ç´¢å¼•</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/about/">è¿°å·±</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/links/">å‹é“¾</a>
              </li> 
                   
          
          
            <li class="menu-item search-btn">
              <a href="#">Search</a>
            </li>
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
        </div>
        <div class="post-title">
            
            
                ã€fuzzã€‘AFLç™½çš®ä¹¦ä¸­è‹±åŒè¯­ç‰ˆ
            
            
        </div>
        <span class="post-date">
            8æœˆ 23, 2023
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <h2 id="å‰è¨€"><a href="#å‰è¨€" class="headerlink" title="å‰è¨€"></a>å‰è¨€</h2><blockquote>
<p>æœ€è¿‘æƒ³ç ”ç©¶ç ”ç©¶AFLæ•´ä½“å†…éƒ¨é€»è¾‘æºç ï¼Œé¢è¯•æ—¶ä¹Ÿé‡åˆ°äº†åŒæ ·çš„é—®é¢˜ï¼Œå†³å®šä»AFLç™½çš®ä¹¦å¼€å§‹çœ‹çœ‹ã€‚ç½‘ä¸Šæœ‰å¾ˆå¤šç¿»è¯‘ç‰ˆï¼Œä½†æ˜¯è¦ä¸å°±æ˜¯æ²¡å†™å®Œï¼Œè¦ä¸å°±æ˜¯æœºç¿»ç—•è¿¹å¤ªé‡ã€‚å†³å®šè‡ªå·±å®Œæˆè¿™ä¸ªä»»åŠ¡ï¼Œäº‰å–åœ¨ä¸€å‘¨å†…å®Œæˆå¤§éƒ¨åˆ†æ ¸å¿ƒæºç çš„åˆ†æã€‚åˆæƒ³åˆ°ä¹‹å‰çœ‹<a href="https://loora1n.github.io/2023/04/24/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%A4%8D%E4%B9%A0/">ç½‘ç»œåè®®æ ˆ</a>å’Œ<a href="https://loora1n.github.io/2022/11/29/%E3%80%90IO_FILE%E3%80%91%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%A6%82%E8%A7%88/">IO_FILE</a>æ—¶çš„å™©æ¢¦äº†ğŸ˜­ğŸ˜­ğŸ˜­</p>
</blockquote>
<p>æœ¬äººè‹±è¯­æ°´å¹³æœ‰é™ï¼Œå¦‚æœ‰é—®é¢˜å¯ä»¥æ–‡æœ«è¯„è®ºåŒºç›´æ¥æŒ‡å‡ºã€‚æˆ‘æƒ³åšä¸­è‹±åŒè¯­ç‰ˆä¹Ÿæ˜¯å°½é‡åœ¨ä¸€å®šç¨‹åº¦ä¸Šé˜²æ­¢å¤§å®¶è¢«æˆ‘çš„è¹©è„šç¿»è¯‘å¸¦åã€‚</p>
<p>ç™½çš®ä¹¦çš„åŸæ–‡éƒ¨åˆ†æˆ‘éƒ½ä¼šä½¿ç”¨markdownçš„å¼•ç”¨è¯­æ³•ï¼Œå¦å¤–ï¼Œå…¨æ–‡ä½¿ç”¨AFLç®€å†™æ›¿ä»£American fuzzy lop.</p>
<blockquote>
<p>AFLç™½çš®ä¹¦åŸæ–‡ï¼š<a target="_blank" rel="noopener" href="https://lcamtuf.coredump.cx/afl/technical_details.txt">lcamtuf.coredump.cx&#x2F;afl&#x2F;technical_details.txt</a></p>
<p>AFLé¡¹ç›®åœ°å€ï¼š<a target="_blank" rel="noopener" href="https://github.com/google/AFL">google&#x2F;AFL: american fuzzy lop - a security-oriented fuzzer (github.com)</a></p>
<p>æœ¬æ–‡ä¹Ÿéƒ¨åˆ†å‚è€ƒï¼š<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cc7a486e5adb">ç¿»è¯‘afl-fuzzç™½çš®ä¹¦ - ç®€ä¹¦ (jianshu.com)</a></p>
</blockquote>
<h2 id="æ–‡æ¡£ä»‹ç»"><a href="#æ–‡æ¡£ä»‹ç»" class="headerlink" title="æ–‡æ¡£ä»‹ç»"></a>æ–‡æ¡£ä»‹ç»</h2><blockquote>
<p>This document provides a quick overview of the guts of American Fuzzy Lop. See README for the general instruction manual; and for a discussion of motivations and design goals behind AFL, see historical_notes.txt.</p>
</blockquote>
<p>æœ¬æ–‡æ¡£ä¸ºAFLçš„å†…éƒ¨ç»“æ„æä¾›äº†ä¸€ä¸ªç®€è¦çš„æ¦‚è¿°ã€‚é€šç”¨è¯´æ˜æ‰‹å†Œå¯ä»¥ç›´æ¥æŸ¥é˜…README]éƒ¨åˆ†ï¼Œå¦å¤–ï¼Œæœ‰å…³AFLèƒŒåçš„è®¾è®¡ç›®æ ‡å’ŒåŠ¨æœºå¯ä»¥å‚é˜…hisrotical_notes.txtã€‚</p>
<h2 id="0ï¼‰Design-statement-è®¾è®¡è¯´æ˜"><a href="#0ï¼‰Design-statement-è®¾è®¡è¯´æ˜" class="headerlink" title="0ï¼‰Design statement è®¾è®¡è¯´æ˜"></a>0ï¼‰Design statement è®¾è®¡è¯´æ˜</h2><blockquote>
<p>American Fuzzy Lop does its best not to focus on any singular principle of<br>operation and not be a proof-of-concept for any specific theory. The tool can<br>be thought of as a collection of hacks that have been tested in practice,<br>found to be surprisingly effective, and have been implemented in the simplest,<br>most robust way I could think of at the time</p>
</blockquote>
<p>AFLå°½åŠ›ä¸å…³æ³¨ä»»ä½•å•ä¸€æ“ä½œçš„åŸç†ï¼ŒåŒæ—¶ä¹Ÿä¸æ˜¯ä»»ä½•ç‰¹å®šç†è®ºçš„POCã€‚è¿™ä¸ªå·¥å…·å¯ä»¥çœ‹ä½œæ˜¯ä¸€ä¸ªhackå·¥å…·çš„é›†åˆï¼Œè¿™äº›å·¥å…·åœ¨å®é™…çš„éªŒè¯æµ‹è¯•åœºæ™¯ä¸­éå¸¸æœ‰æ•ˆï¼Œå› æ­¤æˆ‘ç”¨äº†é‚£æ—¶æˆ‘èƒ½æƒ³åˆ°çš„æœ€ç®€æ´æœ€å…·é²æ£’æ€§çš„æ–¹å¼å®ç°è®¾è®¡äº†å®ƒã€‚</p>
<blockquote>
<p>Many of the resulting features are made possible thanks to the availability of<br>lightweight instrumentation that served as a foundation for the tool, but this<br>mechanism should be thought of merely as a means to an end. The only true<br>governing principles are speed, reliability, and ease of use</p>
</blockquote>
<p>è®¸å¤šåŠŸèƒ½èƒ½å¤Ÿå®ç°ï¼Œéƒ½æ˜¯å¤šäºäº†å°†è½»é‡åŒ–å·¥å…·çš„å¯ç”¨æ€§ä½œä¸ºè¯¥é¡¹ç›®çš„åŸºç¡€ï¼Œä½†æ˜¯è¿™ç§æœºåˆ¶åº”è¯¥ä»…ä»…è¢«è§†ä½œä¸ºäº†å®ç°è®¾è®¡ç›®çš„çš„ä¸€ç§æ‰‹æ®µã€‚æœ¬é¡¹ç›®çœŸæ­£çš„å”¯ä¸€çš„ç®¡ç†åŸåˆ™åº”æ˜¯é«˜æ•ˆæ€§ã€ç¨³å®šæ€§å’Œæ˜“ç”¨æ€§ã€‚</p>
<h2 id="1ï¼‰Coverage-measurements-è¦†ç›–ç‡æµ‹é‡"><a href="#1ï¼‰Coverage-measurements-è¦†ç›–ç‡æµ‹é‡" class="headerlink" title="1ï¼‰Coverage measurements è¦†ç›–ç‡æµ‹é‡"></a>1ï¼‰Coverage measurements è¦†ç›–ç‡æµ‹é‡</h2><blockquote>
<p>The instrumentation injected into compiled programs captures branch (edge)<br>coverage, along with coarse branch-taken hit counts. The code injected at<br>branch points is essentially equivalent to:</p>
</blockquote>
<p>é€šè¿‡å‘å·²ç¼–è¯‘ç¨‹åºæ³¨å…¥æ£€æµ‹ä»£ç æ¥æ•è·ä»£ç åˆ†æ”¯ï¼ˆæˆ–è¾¹ç¼˜ï¼‰çš„è¦†ç›–èŒƒå›´ï¼ŒåŒæ—¶ç²—ç•¥å¾—è®°å½•åˆ†æ”¯å‘½ä¸­è®¡æ•°ã€‚åœ¨åˆ†æ”¯ç‚¹æ³¨å…¥å¾—ä»£ç æœ¬è´¨ä¸Šç›¸å½“äºå¦‚ä¸‹ä¼ªä»£ç ï¼š</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;</span><br><span class="line">shared_mem[cur_location ^ prev_location]++; </span><br><span class="line">prev_location = cur_location &gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The cur_location value is generated randomly to simplify the process of<br>linking complex projects and keep the XOR output distributed uniformly.</p>
</blockquote>
<ul>
<li>cur_location çš„å€¼æ˜¯éšæœºç”Ÿæˆçš„ï¼Œä»¥ç®€åŒ–é“¾æ¥å¤æ‚é¡¹ç›®çš„è¿‡ç¨‹å¹¶ä¿æŒ XOR è¾“å‡ºå‡åŒ€åˆ†å¸ƒã€‚</li>
</ul>
<blockquote>
<p>The shared_mem[] array is a 64 kB SHM region passed to the instrumented binary<br>by the caller. Every byte set in the output map can be thought of as a hit for<br>a particular (branch_src, branch_dst) tuple in the instrumented code.</p>
</blockquote>
<ul>
<li>Shared_mem[] æ•°ç»„æ˜¯ä¸€ä¸ª 64 kB SHM åŒºåŸŸï¼Œç”±è°ƒç”¨è€…ä¼ é€’ç»™å·²æ£€æµ‹çš„äºŒè¿›åˆ¶æ–‡ä»¶ã€‚è¾“å‡ºæ˜ å°„ä¸­çš„æ¯ä¸ªå­—èŠ‚é›†éƒ½å¯ä»¥è¢«è®¤ä¸ºæ˜¯æ£€æµ‹ä»£ç ä¸­ç‰¹å®šï¼ˆbranch_srcï¼Œbranch_dstï¼‰å…ƒç»„çš„å‘½ä¸­ã€‚</li>
</ul>
<blockquote>
<p>The size of the map is chosen so that collisions are sporadic with almost all<br>of the intended targets, which usually sport between 2k and 10k discoverable<br>branch points:</p>
</blockquote>
<p>é€‰æ‹©è¿™ä¸ªå¤§å°çš„æ˜ å°„ï¼Œæ˜¯ä¸ºäº†ç»Ÿè®¡å‡ ä¹æ‰€æœ‰é¢„æµ‹çš„ç›®æ ‡çš„å°‘é‡ç¢°æ’ï¼Œè€Œè¿™äº›ç›®æ ‡é€šå¸¸æœ‰2Kåˆ°10Kä¸ªå¯è§çš„åˆ†æ”¯ç‚¹ï¼š</p>
<table>
<thead>
<tr>
<th align="center">Branch cnt</th>
<th align="center">Colliding tuples</th>
<th align="center">Example targets</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1,000</td>
<td align="center">0.75%</td>
<td align="center">giflib, lzo</td>
</tr>
<tr>
<td align="center">2,000</td>
<td align="center">1.5%</td>
<td align="center">zlib, tar, xz</td>
</tr>
<tr>
<td align="center">5,000</td>
<td align="center">3.5%</td>
<td align="center">libpng, libwebp</td>
</tr>
<tr>
<td align="center">10,000</td>
<td align="center">7%</td>
<td align="center">libxml</td>
</tr>
<tr>
<td align="center">20,000</td>
<td align="center">14%</td>
<td align="center">sqlite</td>
</tr>
<tr>
<td align="center">50,000</td>
<td align="center">30%</td>
<td align="center">-</td>
</tr>
</tbody></table>
<blockquote>
<p>At the same time, its size is small enough to allow the map to be analyzed<br>in a matter of microseconds on the receiving end, and to effortlessly fit<br>within L2 cache.</p>
</blockquote>
<p>åŒæ—¶ï¼Œç”±äºä»–çš„sizeè¶³å¤Ÿçš„å°ï¼Œå¾—ä»¥å…è®¸æ¥æ”¶ç«¯å¯ä»¥åœ¨å‡ å¾®ç§’çš„æ—¶é—´å†…åˆ†ææ˜ å°„ï¼Œå¹¶å°†å…¶æ”¾å…¥äºŒçº§ç¼“å­˜ä¸­ã€‚</p>
<blockquote>
<p>This form of coverage provides considerably more insight into the execution<br>path of the program than simple block coverage. In particular, it trivially<br>distinguishes between the following execution traces:</p>
</blockquote>
<p>ä¸ç®€å•çš„å—è¦†ç›–ç›¸æ¯”ï¼Œè¿™ç§å½¢å¼çš„è¦†ç›–å¯ä»¥æ›´æ·±å…¥åœ°äº†è§£ç¨‹åºçš„æ‰§è¡Œè·¯å¾„ã€‚ç‰¹åˆ«æ˜¯å®ƒå¯ä»¥è½»æ˜“åœ°åŒºåˆ†ä»¥ä¸‹æ‰§è¡Œæµç¨‹:</p>
<ul>
<li>A -&gt; B -&gt; C -&gt; D -&gt; E (tuples: AB, BC, CD, DE)</li>
<li>A -&gt; B -&gt; D -&gt; C -&gt; E (tuples: AB, BD, DC, CE)</li>
</ul>
<blockquote>
<p>This aids the discovery of subtle fault conditions in the underlying code,<br>because security vulnerabilities are more often associated with unexpected<br>or incorrect state transitions than with merely reaching a new basic block.</p>
</blockquote>
<p>è¿™æœ‰åŠ©äºå‘ç°åº•å±‚ä»£ç ä¸­çš„å¾®å¦™æ•…éšœæƒ…å†µï¼Œå› ä¸ºå®‰å…¨æ¼æ´é€šå¸¸ä¸æ„å¤–æˆ–ä¸æ­£ç¡®çš„çŠ¶æ€è½¬æ¢ç›¸å…³ï¼Œè€Œä¸æ˜¯ä»…ä»…ä¸åˆ°è¾¾æ–°çš„åŸºæœ¬å—ç›¸å…³ã€‚</p>
<blockquote>
<p>The reason for the shift operation in the last line of the pseudocode shown<br>earlier in this section is to preserve the directionality of tuples (without<br>this, A ^ B would be indistinguishable from B ^ A) and to retain the identity<br>of tight loops (otherwise, A ^ A would be obviously equal to B ^ B).</p>
</blockquote>
<p>æœ¬èŠ‚å‰é¢æ‰€ç¤ºçš„ä¼ªä»£ç æœ€åä¸€è¡Œä¸­è¿›è¡Œç§»ä½æ“ä½œçš„åŸå› æ˜¯ä¸ºäº†ä¿ç•™å…ƒç»„çš„æ–¹å‘æ€§ï¼ˆæ²¡æœ‰è¿™ä¸ªï¼ŒA ^ B å°†ä¸ B ^ A æ— æ³•åŒºåˆ†ï¼‰å¹¶ä¿ç•™ç´§å¯†å¾ªç¯çš„æ ‡è¯†ï¼ˆå¦åˆ™, A ^ A æ˜¾ç„¶ç­‰äº B ^ B)ã€‚</p>
<p><em><del>é¢˜å¤–è¯ï¼Œæˆ‘ä¸çŸ¥é“ä¸ºä»€ä¹ˆå¤§å®¶éƒ½å–œæ¬¢æŠŠè¿™ä¸ªåœ°æ–¹çš„ç§»ä½ç¿»è¯‘æˆå·¦ç§»ï¼Œä¸è®ºæ˜¯ç¿»è¯‘è¿˜æ˜¯ä»£ç å±‚é¢éƒ½ä¸åº”è¯¥å‡ºç°è¿™ç§é”™è¯¯å§</del></em></p>
<blockquote>
<p>The absence of simple saturating arithmetic opcodes on Intel CPUs means that<br>the hit counters can sometimes wrap around to zero. Since this is a fairly<br>unlikely and localized event, itâ€™s seen as an acceptable performance trade-off.</p>
</blockquote>
<p>è‹±ç‰¹å°” CPU ä¸Šç¼ºä¹ç®€å•çš„é¥±å’Œç®—æœ¯æ“ä½œç ï¼Œè¿™æ„å‘³ç€å‘½ä¸­è®¡æ•°å™¨æœ‰æ—¶ä¼šå›æ»šåˆ°é›¶ã€‚ç”±äºè¿™æ˜¯ä¸€ä¸ªç›¸å½“ä¸å¯èƒ½å‘ç”Ÿçš„å±€éƒ¨äº‹ä»¶ï¼Œå› æ­¤å®ƒè¢«è§†ä¸ºå¯æ¥å—çš„æ€§èƒ½æƒè¡¡ã€‚</p>
<h2 id="2ï¼‰Detecting-new-behaviors-æ£€æµ‹æ–°è¡Œä¸º"><a href="#2ï¼‰Detecting-new-behaviors-æ£€æµ‹æ–°è¡Œä¸º" class="headerlink" title="2ï¼‰Detecting new behaviors æ£€æµ‹æ–°è¡Œä¸º"></a>2ï¼‰Detecting new behaviors æ£€æµ‹æ–°è¡Œä¸º</h2><blockquote>
<p>The fuzzer maintains a global map of tuples seen in previous executions; this<br>data can be rapidly compared with individual traces and updated in just a couple<br>of dword- or qword-wide instructions and a simple loop.</p>
</blockquote>
<p>æ¨¡ç³Šå™¨ç»´æŠ¤å…ˆå‰æ‰§è¡Œä¸­çœ‹åˆ°çš„å…ƒç»„çš„å…¨å±€æ˜ å°„ï¼›è¯¥æ•°æ®å¯ä»¥å¿«é€Ÿä¸å•ç‹¬çš„è¿¹çº¿è¿›è¡Œæ¯”è¾ƒï¼Œå¹¶åªéœ€å‡ ä¸ªdwordæˆ–qwordçš„æŒ‡ä»¤å’Œä¸€ä¸ªç®€å•çš„å¾ªç¯å³å¯æ›´æ–°ã€‚</p>
<blockquote>
<p>When a mutated input produces an execution trace containing new tuples, the<br>corresponding input file is preserved and routed for additional processing<br>later on (see section #3). Inputs that do not trigger new local-scale state<br>transitions in the execution trace (i.e., produce no new tuples) are discarded,<br>even if their overall control flow sequence is unique.</p>
</blockquote>
<p>å½“å˜å¼‚çš„è¾“å…¥äº§ç”ŸåŒ…å«æ–°å…ƒç»„çš„ç¨‹åºæ‰§è¡Œæµæ—¶ï¼Œç›¸åº”çš„è¾“å…¥æ–‡ä»¶å°†è¢«ä¿ç•™å¹¶ä»¥ä¾›ç¨åè¿›è¡Œå…¶ä»–å¤„ç†ï¼ˆè¯·å‚é˜…ç¬¬ #3 èŠ‚ï¼‰ã€‚åœ¨æ‰§è¡Œè·Ÿè¸ªä¸­ï¼Œä¸è§¦å‘æ–°çš„å±€éƒ¨è§„æ¨¡çŠ¶æ€è½¬æ¢ï¼ˆå³ä¸äº§ç”Ÿæ–°å…ƒç»„ï¼‰çš„è¾“å…¥å°†è¢«ä¸¢å¼ƒï¼Œå³ä½¿å®ƒä»¬çš„æ€»ä½“æ§åˆ¶æµåºåˆ—æ˜¯å”¯ä¸€çš„</p>
<blockquote>
<p>This approach allows for a very fine-grained and long-term exploration of<br>program state while not having to perform any computationally intensive and<br>fragile global comparisons of complex execution traces, and while avoiding the<br>scourge of path explosion.</p>
</blockquote>
<p>è¿™ç§æ–¹æ³•å…è®¸å¯¹ç¨‹åºçŠ¶æ€è¿›è¡Œéå¸¸ç»†ç²’åº¦å’Œé•¿æœŸçš„æ¢ç´¢ï¼Œè€Œä¸å¿…å¯¹å¤æ‚çš„æ‰§è¡Œè·Ÿè¸ªæ‰§è¡Œä»»ä½•è®¡ç®—å¯†é›†å‹å’Œè„†å¼±çš„å…¨å±€æ¯”è¾ƒï¼ŒåŒæ—¶é¿å…è·¯å¾„çˆ†ç‚¸çš„å±å®³ã€‚</p>
<blockquote>
<p>To illustrate the properties of the algorithm, consider that the second trace<br>shown below would be considered substantially new because of the presence of<br>new tuples (CA, AE):</p>
</blockquote>
<p>ä¸ºäº†è¯´æ˜è¯¥ç®—æ³•çš„å±æ€§ï¼Œè¯·è€ƒè™‘ç”±äºæ–°å…ƒç»„ï¼ˆCAã€AEï¼‰çš„å­˜åœ¨ï¼Œä¸‹é¢æ˜¾ç¤ºçš„ç¬¬äºŒæ¡è½¨è¿¹å°†è¢«è§†ä¸ºå®è´¨ä¸Šæ˜¯æ–°çš„ï¼š</p>
<ul>
<li>#1:	A -&gt; B -&gt; C -&gt; D -&gt; E </li>
<li>#2:    A -&gt; B -&gt; C -&gt; A -&gt; E</li>
</ul>
<blockquote>
<p>At the same time, with #2 processed, the following pattern will not be seen<br>as unique, despite having a markedly different overall execution path:</p>
</blockquote>
<p>åŒæ—¶ï¼Œè‹¥ä¿å­˜#2è·¯å¾„åï¼Œå°½ç®¡ä¸‹é¢çš„ä¾‹å­æ•´ä½“æ‰§è¡Œè·¯å¾„æ˜æ˜¾ä¸åŒï¼Œä½†å°†ä¸ä¼šè¢«è§†ä¸ºä¸€ä¸ªæ–°çš„è·¯å¾„ï¼š</p>
<ul>
<li>#3:	A -&gt; B -&gt; C -&gt; A -&gt; B -&gt; C -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E</li>
</ul>
<blockquote>
<p>In addition to detecting new tuples, the fuzzer also considers coarse tuple<br>hit counts. These are divided into several buckets:</p>
</blockquote>
<p>é™¤äº†æ£€æµ‹æ–°å…ƒç»„ä¹‹å¤–ï¼Œæ¨¡ç³Šå™¨è¿˜è€ƒè™‘ç²—å…ƒç»„å‘½ä¸­è®¡æ•°ã€‚è¿™äº›è¢«åˆ†ä¸ºå‡ ä¸ªbuckets:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span><span class="number">-7</span>, <span class="number">8</span><span class="number">-15</span>, <span class="number">16</span><span class="number">-31</span>, <span class="number">32</span><span class="number">-27</span>, <span class="number">128</span>+</span><br></pre></td></tr></table></figure>

<blockquote>
<p>To some extent, the number of buckets is an implementation artifact: it allows<br>an in-place mapping of an 8-bit counter generated by the instrumentation to<br>an 8-position bitmap relied on by the fuzzer executable to keep track of the<br>already-seen execution counts for each tuple.</p>
</blockquote>
<p>ä»æŸç§æ„ä¹‰ä¸Šè®²ï¼Œè¿™äº›bucketsçš„æ•°é‡æ˜¯ä¸€ç§æ‰§è¡Œå·¥å…·ï¼šå®ƒå…è®¸å°†ç”Ÿæˆçš„ 8 ä½è®¡æ•°å™¨å°±åœ°æ˜ å°„åˆ°fuzzeræ‰§è¡Œå™¨æ‰€ä¾èµ–çš„ 8 ä½ä½å›¾ï¼Œä»¥è·Ÿè¸ªå·²ç»çœ‹åˆ°çš„æ•°æ®æ¯ä¸ªå…ƒç»„çš„æ‰§è¡Œè®¡æ•°</p>
<blockquote>
<p>Changes within the range of a single bucket are ignored; transition from one<br>bucket to another is flagged as an interesting change in program control flow,<br>and is routed to the evolutionary process outlined in the section below.</p>
</blockquote>
<p>å•ä¸ªbucketèŒƒå›´å†…çš„å˜åŒ–ä¼šè¢«å¿½ç•¥æ‰ï¼›ç„¶è€Œå…ƒç»„ä»ä¸€ä¸ªbucketåˆ°å¦ä¸€ä¸ªbucketçš„è½¬æ¢ä¼šè¢«æ ‡è®°ä¸ºç¨‹åºæ§åˆ¶æµä¸­çš„ä¸€ä¸ªæœ‰è¶£çš„å˜åŒ–ï¼Œç„¶åä¼šè¢«ä¿å­˜ä¸‹æ¥ä¼ é€’è‡³ä¸‹ä¸€è½®çš„æ¼”åŒ–è¿‡ç¨‹ä¸­å»ã€‚</p>
<blockquote>
<p>The hit count behavior provides a way to distinguish between potentially<br>interesting control flow changes, such as a block of code being executed<br>twice when it was normally hit only once. At the same time, it is fairly<br>insensitive to empirically less notable changes, such as a loop going from<br>47 cycles to 48. The counters also provide some degree of â€œaccidentalâ€<br>immunity against tuple collisions in dense trace maps.</p>
</blockquote>
<p>å‘½ä¸­è®¡æ•°è¡Œä¸ºæä¾›äº†ä¸€ç§åŒºåˆ†æ½œåœ¨çš„æœ‰è¶£çš„æ§åˆ¶æµå˜æ¢çš„æ–¹æ³•ï¼Œä¾‹å¦‚ï¼Œé€šå¸¸åªå‘½ä¸­ä¸€æ¬¡çš„ä»£ç å—è¢«æ‰§è¡Œäº†ä¸¤æ¬¡ã€‚åŒæ—¶ï¼Œå®ƒå¯¹é€šå¸¸ç»éªŒä¸Šä¸å¤ªæ˜¾ç€çš„å˜åŒ–ç›¸å½“ä¸æ•æ„Ÿï¼Œä¾‹å¦‚ä» 47 ä¸ªå‘¨æœŸå˜ä¸º 48 ä¸ªå‘¨æœŸçš„å¾ªç¯ã€‚è®¡æ•°å™¨è¿˜æä¾›ä¸€å®šç¨‹åº¦çš„â€œæ„å¤–â€å…ç–«åŠ›ï¼Œé˜²æ­¢å¯†é›†æµæ˜ å°„ä¸­çš„å…ƒç»„ç¢°æ’</p>
<blockquote>
<p>The execution is policed fairly heavily through memory and execution time<br>limits; by default, the timeout is set at 5x the initially-calibrated<br>execution speed, rounded up to 20 ms. The aggressive timeouts are meant to<br>prevent dramatic fuzzer performance degradation by descending into tarpits<br>that, say, improve coverage by 1% while being 100x slower; we pragmatically<br>reject them and hope that the fuzzer will find a less expensive way to reach<br>the same code. Empirical testing strongly suggests that more generous time<br>limits are not worth the cost.</p>
</blockquote>
<p>é€šè¿‡å†…å­˜å’Œæ‰§è¡Œæ—¶é—´å¯¹æ‰§è¡Œè¿‡ç¨‹è¿›è¡Œç›¸å½“ä¸¥æ ¼çš„é™åˆ¶ï¼›é»˜è®¤æƒ…å†µä¸‹ï¼Œè¶…æ—¶è®¾ç½®ä¸ºåˆå§‹æ ¡å‡†æ‰§è¡Œé€Ÿåº¦çš„ 5 å€ï¼Œå¤§çº¦ä¸º 20 æ¯«ç§’ã€‚æ¿€è¿›çš„è¶…æ—¶é™åˆ¶æ˜¯ä¸ºäº†ï¼Œé˜²æ­¢æ¨¡ç³Šå™¨æ€§èƒ½å› é™·å…¥æŸç§â€é™·é˜±â€œè€Œæ€¥å‰§ä¸‹é™ï¼Œä¾‹å¦‚ï¼Œå°†è¦†ç›–ç‡æé«˜ 1%ï¼ŒåŒæ—¶é€Ÿåº¦æ…¢ 100 å€ï¼›æˆ‘ä»¬ä¸€å®šä¼šæ‹’ç»è¿™ç§æ–¹æ³•ï¼Œå¹¶å¸Œæœ›fuzzerèƒ½å¤Ÿæ‰¾åˆ°ä¸€ç§ä»£ä»·æ›´ä½çš„æ–¹å¼çš„æ–¹æ³•æ¥è¾¾åˆ°ç›¸åŒçš„ä»£ç å—ã€‚åŒæ—¶ï¼Œå®è¯æ£€éªŒä¹Ÿéå¸¸å¼ºçƒˆåœ°è¡¨æ˜ï¼Œæ›´å®½æ¾çš„æ—¶é—´é™åˆ¶æ˜¯ä¸å€¼å¾—çš„ã€‚</p>
<h2 id="3ï¼‰Evolving-the-input-queue-æ”¹è¿›è¾“å…¥é˜Ÿåˆ—"><a href="#3ï¼‰Evolving-the-input-queue-æ”¹è¿›è¾“å…¥é˜Ÿåˆ—" class="headerlink" title="3ï¼‰Evolving the input queue æ”¹è¿›è¾“å…¥é˜Ÿåˆ—"></a>3ï¼‰Evolving the input queue æ”¹è¿›è¾“å…¥é˜Ÿåˆ—</h2><blockquote>
<p>Mutated test cases that produced new state transitions within the program are<br>added to the input queue and used as a starting point for future rounds of<br>fuzzing. They supplement, but do not automatically replace, existing finds.</p>
</blockquote>
<p>åœ¨ç¨‹åºä¸­äº§ç”Ÿæ–°çŠ¶æ€è½¬æ¢çš„å˜å¼‚æµ‹è¯•ç”¨ä¾‹è¢«æ·»åŠ åˆ°è¾“å…¥é˜Ÿåˆ—ä¸­ï¼Œå¹¶ç”¨ä½œæœªæ¥å‡ è½®æ¨¡ç³Šæµ‹è¯•çš„èµ·ç‚¹ã€‚å®ƒä»¬è¡¥å……ä½†ä¸ä¼šè‡ªåŠ¨å–ä»£ç°æœ‰å‘ç°åœ°è·¯å¾„ã€‚</p>
<blockquote>
<p>In contrast to more greedy genetic algorithms, this approach allows the tool<br>to progressively explore various disjoint and possibly mutually incompatible<br>features of the underlying data format, as shown in this image:</p>
</blockquote>
<p>ä¸æ›´è´ªå©ªçš„é—ä¼ ç®—æ³•ç›¸æ¯”ï¼Œè¿™ç§æ–¹æ³•å…è®¸å·¥å…·é€æ­¥æ¢ç´¢å„ç§ä¸ç›¸äº¤ä¸”å¯èƒ½ç›¸äº’ä¸å…¼å®¹åœ°ç‰¹å¾çš„åº•å±‚æ•°æ®æ ¼å¼ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤º:</p>
<p><img src="/img/article/fuzzdoc/afl_gzip.png" alt="afl"></p>
<p>è¿™é‡Œè®¨è®ºè¯¥ç®—æ³•ç»“æœçš„å‡ ä¸ªå®é™…ç¤ºä¾‹ï¼š</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html">http://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html</a></li>
<li><a target="_blank" rel="noopener" href="http://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html">http://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html</a></li>
</ul>
<blockquote>
<p>The synthetic corpus produced by this process is essentially a compact<br>collection of â€œhmm, this does something new!â€ input files, and can be used to<br>seed any other testing processes down the line (for example, to manually<br>stress-test resource-intensive desktop apps).</p>
</blockquote>
<p>æ­¤è¿‡ç¨‹ç”Ÿæˆçš„åˆæˆè¯­æ–™åº“æœ¬è´¨ä¸Šæ˜¯ï¼Œâ€œå—¯ï¼Œå¤šäº†ä¸€äº›æ–°çš„ä¸œè¥¿ï¼â€è¿™æ ·çš„è¾“å…¥æ–‡ä»¶çš„ç´§å‡‘é›†åˆï¼Œå¹¶ä¸”å¯ç”¨äºä¸ºä»»ä½•å…¶ä»–æµ‹è¯•æµç¨‹æä¾›ç§å­ï¼ˆä¾‹å¦‚ï¼Œæ‰‹åŠ¨å¯¹èµ„æºå¯†é›†å‹æ¡Œé¢åº”ç”¨ç¨‹åºè¿›è¡Œå‹åŠ›æµ‹è¯•ï¼‰</p>
<blockquote>
<p>With this approach, the queue for most targets grows to somewhere between 1k<br>and 10k entries; approximately 10-30% of this is attributable to the discovery<br>of new tuples, and the remainder is associated with changes in hit counts</p>
</blockquote>
<p>é€šè¿‡è¿™ç§æ–¹æ³•ï¼Œå¤§å¤šæ•°ç›®æ ‡çš„é˜Ÿåˆ—ä¼šå¢é•¿åˆ° 1k åˆ° 10k æ¡ç›®ä¹‹é—´ï¼›å…¶ä¸­å¤§çº¦ 10-30% å½’å› äºæ–°å…ƒç»„çš„å‘ç°ï¼Œå…¶ä½™éƒ¨åˆ†ä¸å‘½ä¸­è®¡æ•°çš„å˜åŒ–æœ‰å…³ã€‚</p>
<blockquote>
<p>The following table compares the relative ability to discover file syntax and<br>explore program states when using several different approaches to guided<br>fuzzing. The instrumented target was GNU patch 2.7.3 compiled with -O3 and<br>seeded with a dummy text file; the session consisted of a single pass over the<br>input queue with afl-fuzz:</p>
</blockquote>
<p>ä¸‹è¡¨æ¯”è¾ƒäº†ä½¿ç”¨å‡ ç§ä¸åŒæ–¹æ³•è¿›è¡Œå¼•å¯¼æ¨¡ç³Šæµ‹è¯•æ—¶å‘ç°æ–‡ä»¶è¯­æ³•å’Œæ¢ç´¢ç¨‹åºçŠ¶æ€çš„ç›¸å¯¹èƒ½åŠ›ã€‚æ£€æµ‹çš„ç›®æ ‡æ˜¯ä½¿ç”¨ -O3 ç¼–è¯‘çš„ GNU è¡¥ä¸ 2.7.3ï¼Œå¹¶ä½¿ç”¨è™šæ‹Ÿæ–‡æœ¬æ–‡ä»¶ä½œä¸ºç§å­ï¼›è¯¥ä¼šè¯ç”± afl-fuzz å•æ¬¡ä¼ é€’çš„è¾“å…¥é˜Ÿåˆ—ç»„æˆï¼š</p>
<table>
<thead>
<tr>
<th align="center">Fuzzer guidance strategy used</th>
<th align="center">Blocks reached</th>
<th align="center">Edges reached</th>
<th align="center">Edge hit cnt var</th>
<th align="center">Highest-coverage test case generated</th>
</tr>
</thead>
<tbody><tr>
<td align="center">(Initial file)</td>
<td align="center">156</td>
<td align="center">163</td>
<td align="center">1.00</td>
<td align="center">(none)</td>
</tr>
<tr>
<td align="center">Blind fuzzing S</td>
<td align="center">182</td>
<td align="center">205</td>
<td align="center">2.23</td>
<td align="center">First 2 B of RCS diff</td>
</tr>
<tr>
<td align="center">Blind fuzzing L</td>
<td align="center">228</td>
<td align="center">265</td>
<td align="center">2.23</td>
<td align="center">First 4 B of -c mode diff</td>
</tr>
<tr>
<td align="center">Block coverage</td>
<td align="center">855</td>
<td align="center">1,130</td>
<td align="center">1.57</td>
<td align="center">Almost-valid RCS diff</td>
</tr>
<tr>
<td align="center">Edge coverage</td>
<td align="center">1,452</td>
<td align="center">2,070</td>
<td align="center">2.18</td>
<td align="center">One-chunk -c mode diff</td>
</tr>
<tr>
<td align="center">AFL model</td>
<td align="center">1,765</td>
<td align="center">2,597</td>
<td align="center">4.99</td>
<td align="center">Four-chunk -c mode diff</td>
</tr>
</tbody></table>
<blockquote>
<p>The first entry for blind fuzzing (â€œSâ€) corresponds to executing just a single<br>round of testing; the second set of figures (â€œLâ€) shows the fuzzer running in a<br>loop for a number of execution cycles comparable with that of the instrumented<br>runs, which required more time to fully process the growing queue.</p>
</blockquote>
<p>blind fuzzingï¼ˆâ€œSâ€ï¼‰çš„ç¬¬ä¸€ä¸ªæ¡ç›®å¯¹åº”äºä»…æ‰§è¡Œä¸€è½®æµ‹è¯•ï¼›ç¬¬äºŒç»„å›¾ï¼ˆâ€œLâ€ï¼‰æ˜¾ç¤ºæ¨¡ç³Šå™¨åœ¨å¾ªç¯ä¸­è¿è¡Œçš„æ‰§è¡Œå‘¨æœŸæ•°ä¸æ£€æµ‹è¿è¡Œçš„è¿è¡Œå‘¨æœŸç›¸å½“ï¼Œè¿™éœ€è¦æ›´å¤šæ—¶é—´æ¥å®Œå…¨å¤„ç†ä¸æ–­å¢é•¿çš„é˜Ÿåˆ—ã€‚</p>
<blockquote>
<p>Roughly similar results have been obtained in a separate experiment where the<br>fuzzer was modified to compile out all the random fuzzing stages and leave just<br>a series of rudimentary, sequential operations such as walking bit flips.<br>Because this mode would be incapable of altering the size of the input file,<br>the sessions were seeded with a valid unified diff:</p>
</blockquote>
<p>åœ¨å¦ä¸€ä¸ªå®éªŒä¸­è·å¾—äº†å¤§è‡´ç›¸ä¼¼çš„ç»“æœï¼Œå…¶ä¸­æ¨¡ç³Šå™¨è¢«ä¿®æ”¹ä¸ºç¼–è¯‘å‡ºæ‰€æœ‰éšæœºæ¨¡ç³Šé˜¶æ®µï¼Œåªç•™ä¸‹ä¸€ç³»åˆ—åŸºæœ¬çš„é¡ºåºæ“ä½œï¼Œä¾‹å¦‚æ­¥è¡Œä½ç¿»è½¬ã€‚ç”±äºæ­¤æ¨¡å¼æ— æ³•æ›´æ”¹è¾“å…¥æ–‡ä»¶çš„å¤§å°ï¼Œä¼šè¯ä½¿ç”¨æœ‰æ•ˆçš„ç»Ÿä¸€å·®å¼‚è®¾å®šç§å­ï¼š</p>
<table>
<thead>
<tr>
<th align="center">Queue extension strategy used</th>
<th align="center">Blocks reached</th>
<th align="center">Edages reached</th>
<th align="center">Edge hit cnt var</th>
<th align="center">Number of unique crashes found</th>
</tr>
</thead>
<tbody><tr>
<td align="center">(Initial file)</td>
<td align="center">624</td>
<td align="center">717</td>
<td align="center">1.00</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">Blind fuzzing</td>
<td align="center">1,101</td>
<td align="center">1,409</td>
<td align="center">1.60</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">Block coverage</td>
<td align="center">1,255</td>
<td align="center">1,649</td>
<td align="center">1.48</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">Edge coverage</td>
<td align="center">1,259</td>
<td align="center">1,734</td>
<td align="center">1.72</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">AFL model</td>
<td align="center">1,452</td>
<td align="center">2,040</td>
<td align="center">3.16</td>
<td align="center">1</td>
</tr>
</tbody></table>
<blockquote>
<p>At noted earlier on, some of the prior work on genetic fuzzing relied on<br>maintaining a single test case and evolving it to maximize coverage. At least<br>in the tests described above, this â€œgreedyâ€ approach appears to confer no<br>substantial benefits over blind fuzzing strategies.</p>
</blockquote>
<p>å¦‚å‰æ‰€è¿°ï¼Œä¹‹å‰çš„ä¸€äº›é—ä¼ æ¨¡ç³Šæµ‹è¯•å·¥ä½œä¾èµ–äºç»´æŠ¤å•ä¸ªæµ‹è¯•ç”¨ä¾‹å¹¶å¯¹å…¶è¿›è¡Œæ”¹è¿›ä»¥æœ€å¤§åŒ–è¦†ç›–èŒƒå›´ã€‚è‡³å°‘åœ¨ä¸Šè¿°æµ‹è¯•ä¸­ï¼Œè¿™ç§â€œè´ªå©ªâ€æ–¹æ³•ä¼¼ä¹å¹¶æ²¡æœ‰æ¯”ç›²ç›®æ¨¡ç³Šæµ‹è¯•ç­–ç•¥å¸¦æ¥å®è´¨æ€§çš„å¥½å¤„ã€‚</p>
<h2 id="4ï¼‰Culling-the-corpus-è¯­æ–™åº“å‰”é™¤"><a href="#4ï¼‰Culling-the-corpus-è¯­æ–™åº“å‰”é™¤" class="headerlink" title="4ï¼‰Culling the corpus è¯­æ–™åº“å‰”é™¤"></a>4ï¼‰Culling the corpus è¯­æ–™åº“å‰”é™¤</h2><blockquote>
<p>The progressive state exploration approach outlined above means that some of<br>the test cases synthesized later on in the game may have edge coverage that<br>is a strict superset of the coverage provided by their ancestors.</p>
</blockquote>
<p>ä¸Šé¢æ¦‚è¿°çš„æ¸è¿›çŠ¶æ€æ¢ç´¢æ–¹æ³•æ„å‘³ç€ï¼Œåœ¨æµç¨‹ä¸­ç¨ååˆæˆçš„ä¸€äº›æµ‹è¯•ç”¨ä¾‹å¯èƒ½å…·æœ‰è¾¹ç¼˜è¦†ç›–ï¼Œè¿™æ˜¯å…¶ç¥–å…ˆæä¾›çš„è¦†ç›–çš„ä¸¥æ ¼è¶…é›†ã€‚</p>
<blockquote>
<p>To optimize the fuzzing effort, AFL periodically re-evaluates the queue using a<br>fast algorithm that selects a smaller subset of test cases that still cover<br>every tuple seen so far, and whose characteristics make them particularly<br>favorable to the tool.</p>
</blockquote>
<p>ä¸ºäº†ä¼˜åŒ–æ¨¡ç³Šæµ‹è¯•å·¥ä½œï¼ŒAFL ä½¿ç”¨å¿«é€Ÿç®—æ³•å®šæœŸé‡æ–°è¯„ä¼°é˜Ÿåˆ—ï¼Œè¯¥ç®—æ³•é€‰æ‹©è¾ƒå°çš„æµ‹è¯•ç”¨ä¾‹å­é›†ï¼Œè¿™äº›æµ‹è¯•ç”¨ä¾‹ä»ç„¶è¦†ç›–è¿„ä»Šä¸ºæ­¢çœ‹åˆ°çš„æ¯ä¸ªå…ƒç»„ï¼Œå¹¶ä¸”å…¶ç‰¹å¾ä½¿å®ƒä»¬ç‰¹åˆ«é€‚åˆè¯¥å·¥å…·ã€‚</p>
<blockquote>
<p>The algorithm works by assigning every queue entry a score proportional to its<br>execution latency and file size; and then selecting lowest-scoring candidates<br>for each tuple.</p>
</blockquote>
<p>è¯¥ç®—æ³•çš„å·¥ä½œåŸç†æ˜¯ä¸ºæ¯ä¸ªé˜Ÿåˆ—æ¡ç›®åˆ†é…ä¸å…¶æ‰§è¡Œå»¶è¿Ÿå’Œæ–‡ä»¶å¤§å°æˆæ¯”ä¾‹çš„åˆ†æ•°;ç„¶åä¸ºæ¯ä¸ªå…ƒç»„é€‰æ‹©å¾—åˆ†æœ€ä½çš„å€™é€‰é¡¹ã€‚</p>
<blockquote>
<p>The tuples are then processed sequentially using a simple workflow:</p>
<ol>
<li>Find next tuple not yet in the temporary working set,</li>
<li>Locate the winning queue entry for this tuple,</li>
<li>Register <strong>all</strong> tuples present in that entryâ€™s trace in the working set,</li>
<li>Go to #1 if there are any missing tuples in the set.</li>
</ol>
</blockquote>
<p>ç„¶åä½¿ç”¨ä¸€ç§ç®€æ˜“çš„æµç¨‹å¤„ç†è¿™äº›å…ƒç»„ï¼š</p>
<ol>
<li>æ‰¾åˆ°ä¸€ä¸ªæœªåœ¨ä¸´æ—¶å·¥ä½œé›†ä¸­çš„å…ƒç»„</li>
<li>æ‰¾åˆ°è¿™ä¸ªå…ƒç»„çš„winningé˜Ÿåˆ—æ¡ç›®</li>
<li>åœ¨å·¥ä½œé›†ä¸­æ³¨å†Œè¯¥æ¡ç›®çš„<strong>æ‰€æœ‰</strong>å­˜åœ¨çš„å…ƒç»„</li>
<li>å¦‚æœåœ¨é›†åˆé‡Œæœ‰ä»»ä½•ç¼ºå°‘çš„å…ƒç»„ï¼Œè¿”å›æµç¨‹1</li>
</ol>
<blockquote>
<p>The generated corpus of â€œfavoredâ€ entries is usually 5-10x smaller than the<br>starting data set. Non-favored entries are not discarded, but they are skipped<br>with varying probabilities when encountered in the queue:</p>
<ul>
<li><p>If there are new, yet-to-be-fuzzed favorites present in the queue, 99% of non-favored entries will be skipped to get to the favored ones.</p>
</li>
<li><p>If there are no new favorites:</p>
<ul>
<li><p>If the current non-favored entry was fuzzed before, it will be skipped 95% of the time.</p>
</li>
<li><p>If it hasnâ€™t gone through any fuzzing rounds yet, the odds of skipping drop down to 75%.</p>
</li>
</ul>
</li>
</ul>
<p>Based on empirical testing, this provides a reasonable balance between queue </p>
<p>cycling speed and test case diversity.</p>
</blockquote>
<p>ç”Ÿæˆçš„â€é¦–é€‰â€çš„è¯­æ–™åº“é€šå¸¸æ¯”å…¶å®æ•°æ®é›†è¦å° 5-10 å€ã€‚ä¸å—æ¬¢è¿çš„æ¡ç›®ä¸ä¼šè¢«ä¸¢å¼ƒï¼Œä½†å®ƒä»¬åœ¨é˜Ÿåˆ—ä¸­ä¼šä»¥ä¸åŒæ¦‚ç‡è¢«è·³è¿‡ï¼š</p>
<ul>
<li>å¦‚æœé˜Ÿåˆ—ä¸­å­˜åœ¨æ–°çš„ã€å°šæœªè¢«fuzzçš„<strong>favorites</strong>ï¼Œåˆ™99%çš„<strong>non-favored</strong>æ¡ç›®å°†è¢«è·³è¿‡ï¼Œè€Œå»è®¿é—®<strong>favored</strong>æ¡ç›®</li>
<li>å¦‚æœä¸å­˜åœ¨æ–°çš„<strong>favorites</strong>ï¼š<ul>
<li>å¦‚æœå½“å‰<strong>non-favored</strong>æ¡ç›®ä¹‹å‰è¢«fuzzè¿‡ï¼Œåˆ™æœ‰95%çš„å‡ ç‡è·³è¿‡</li>
<li>å¦‚æœå½“å‰<strong>non-favored</strong>æ¡ç›®æœªè¢«fuzzè¿‡ï¼Œåˆ™è·³è¿‡çš„å‡ ç‡ä¸‹é™åˆ°75%</li>
</ul>
</li>
</ul>
<p>åŸºäºå®é™…æµ‹è¯•ï¼Œè¿™ç§æ–¹å¼åœ¨å¾ªç¯é€Ÿåº¦å’Œæµ‹è¯•ç”¨ä¾‹å¤šæ ·æ€§ä¹‹é—´æä¾›äº†åˆç†çš„å¹³è¡¡</p>
<blockquote>
<p>Slightly more sophisticated but much slower culling can be performed on input<br>or output corpora with afl-cmin. This tool permanently discards the redundant<br>entries and produces a smaller corpus suitable for use with afl-fuzz or<br>external tools.</p>
</blockquote>
<p>å¯ä»¥ä½¿ç”¨ afl-cmin å¯¹è¾“å…¥æˆ–è¾“å‡ºè¯­æ–™åº“æ‰§è¡Œç¨å¾®å¤æ‚ä½†é€Ÿåº¦æ…¢å¾—å¤šçš„å‰”é™¤ã€‚æ­¤å·¥å…·ä¼šæ°¸ä¹…ä¸¢å¼ƒå†—ä½™æ¡ç›®ï¼Œå¹¶ç”Ÿæˆé€‚åˆä¸ afl-fuzz æˆ–å¤–éƒ¨å·¥å…·ä¸€èµ·ä½¿ç”¨çš„è¾ƒå°è¯­æ–™åº“ã€‚</p>
<h2 id="5ï¼‰Trimming-input-files-ä¿®å‰ªè¾“å…¥æ–‡ä»¶"><a href="#5ï¼‰Trimming-input-files-ä¿®å‰ªè¾“å…¥æ–‡ä»¶" class="headerlink" title="5ï¼‰Trimming input files ä¿®å‰ªè¾“å…¥æ–‡ä»¶"></a>5ï¼‰Trimming input files ä¿®å‰ªè¾“å…¥æ–‡ä»¶</h2><blockquote>
<p>File size has a dramatic impact on fuzzing performance, both because large<br>files make the target binary slower, and because they reduce the likelihood<br>that a mutation would touch important format control structures, rather than<br>redundant data blocks. This is discussed in more detail in perf_tips.txt.</p>
</blockquote>
<p>æ–‡ä»¶å¤§å°å¯¹æ¨¡ç³Šæµ‹è¯•æ€§èƒ½æœ‰æ˜¾è‘—å½±å“ï¼Œè¿™æ—¢æ˜¯å› ä¸ºå¤§æ–‡ä»¶ä¼šä½¿ç›®æ ‡äºŒè¿›åˆ¶æ–‡ä»¶å˜æ…¢ï¼Œä¹Ÿæ˜¯å› ä¸ºå®ƒä»¬é™ä½äº†çªå˜æ¥è§¦é‡è¦æ ¼å¼æ§åˆ¶ç»“æ„çš„å¯èƒ½æ€§ï¼Œå¢å¤§äº†æ¥è§¦å†—ä½™æ•°æ®å—çš„å¯èƒ½æ€§ã€‚åœ¨perf_tips.txtä¸­å°†å¯¹æ­¤é—®é¢˜åšæ›´è¯¦ç»†åœ°è®¨è®ºã€‚</p>
<blockquote>
<p>The possibility that the user will provide a low-quality starting corpus aside,<br>some types of mutations can have the effect of iteratively increasing the size<br>of the generated files, so it is important to counter this trend.</p>
</blockquote>
<p>å°±ç®—ä¸è€ƒè™‘ç”¨æˆ·è‡ªèº«æä¾›ä½è´¨é‡èµ·å§‹è¯­æ–™åº“çš„å¯èƒ½æ€§ï¼ŒæŸäº›ç±»å‹çš„çªå˜ä¹Ÿå¯èƒ½ä¼šå¯¼è‡´è¿­ä»£åœ°å¢åŠ ç”Ÿæˆæ–‡ä»¶çš„å¤§å°ï¼Œå› æ­¤æ‰­è½¬è¿™ç§å˜åŒ–è¶‹åŠ¿éå¸¸é‡è¦ã€‚</p>
<blockquote>
<p>Luckily, the instrumentation feedback provides a simple way to automatically<br>trim down input files while ensuring that the changes made to the files have no<br>impact on the execution path.</p>
</blockquote>
<p>å¹¸è¿çš„æ˜¯ï¼Œæ£€æµ‹åé¦ˆæä¾›äº†ä¸€ç§ç®€å•çš„æ–¹æ³•æ¥è‡ªåŠ¨ä¿®å‰ªè¾“å…¥æ–‡ä»¶ï¼ŒåŒæ—¶ç¡®ä¿å¯¹æ–‡ä»¶æ‰€åšçš„æ›´æ”¹ä¸ä¼šå½±å“æ‰§è¡Œè·¯å¾„ã€‚</p>
<blockquote>
<p>The built-in trimmer in afl-fuzz attempts to sequentially remove blocks of data<br>with variable length and stepover; any deletion that doesnâ€™t affect the checksum<br>of the trace map is committed to disk. The trimmer is not designed to be<br>particularly thorough; instead, it tries to strike a balance between precision<br>and the number of execve() calls spent on the process, selecting the block size<br>and stepover to match. The average per-file gains are around 5-20%.</p>
</blockquote>
<p>afl-fuzz ä¸­çš„å†…ç½®ä¿®å‰ªå™¨å°è¯•æŒ‰é¡ºåºåˆ é™¤å…·æœ‰å¯å˜é•¿åº¦å’Œè·¨è·çš„æ•°æ®å—;ä»»ä½•ä¸å½±å“è·Ÿè¸ªæ˜ å°„æ ¡éªŒå’Œçš„åˆ é™¤éƒ½å°†æäº¤åˆ°ç£ç›˜ã€‚ä¿®å‰ªå™¨çš„è®¾è®¡ä¸æ˜¯ç‰¹åˆ«å½»åº•ï¼›ç›¸åï¼Œé€šè¿‡é€‰æ‹©åŒ¹é…æ•°æ®å—å¤§å°å’Œè·¨æ­¥å¤§å°ï¼Œå®ƒè¯•å›¾åœ¨ç²¾åº¦å’Œè¿›ç¨‹<code>execve()</code>è°ƒç”¨çš„æ•°é‡ä¸Šå–å¾—å¹³è¡¡ã€‚æ¯ä¸ªæ–‡ä»¶çš„å¹³å‡æ”¶ç›Šä¸º5-20%ã€‚</p>
<blockquote>
<p>The standalone afl-tmin tool uses a more exhaustive, iterative algorithm, and<br>also attempts to perform alphabet normalization on the trimmed files. The<br>operation of afl-tmin is as follows.</p>
</blockquote>
<p>ç‹¬ç«‹çš„ afl-tmin å·¥å…·ä½¿ç”¨æ›´è¯¦å°½çš„è¿­ä»£ç®—æ³•ï¼Œå¹¶ä¸”è¿˜å°è¯•å¯¹ä¿®å‰ªåçš„æ–‡ä»¶æ‰§è¡Œå­—æ¯è§„èŒƒåŒ–ã€‚afl-tminçš„æ“ä½œå¦‚ä¸‹ã€‚</p>
<blockquote>
<p>First, the tool automatically selects the operating mode. If the initial input<br>crashes the target binary, afl-tmin will run in non-instrumented mode, simply<br>keeping any tweaks that produce a simpler file but still crash the target. If<br>the target is non-crashing, the tool uses an instrumented mode and keeps only<br>the tweaks that produce exactly the same execution path.</p>
</blockquote>
<p>é¦–å…ˆï¼Œè¯¥å·¥å…·ä¼šè‡ªåŠ¨é€‰æ‹©æ“ä½œæ¨¡å¼ã€‚å¦‚æœåˆå§‹è¾“å…¥ä½¿ç›®æ ‡äºŒè¿›åˆ¶æ–‡ä»¶å´©æºƒï¼Œafl-tmin å°†ä»¥éæ£€æµ‹æ¨¡å¼è¿è¡Œï¼Œåªéœ€ä¿ç•™ç”Ÿæˆæ›´ç®€å•æ–‡ä»¶ä½†ä»ä¼šä½¿ç›®æ ‡å´©æºƒçš„ä»»ä½•è°ƒæ•´ã€‚å¦‚æœç›®æ ‡æœªå´©æºƒï¼Œåˆ™è¯¥å·¥å…·ä½¿ç”¨æ£€æµ‹æ¨¡å¼ï¼Œå¹¶ä»…ä¿ç•™ç”Ÿæˆå®Œå…¨ç›¸åŒæ‰§è¡Œè·¯å¾„çš„è°ƒæ•´ã€‚</p>
<blockquote>
<p>The actual minimization algorithm is:</p>
<ol>
<li>Attempt to zero large blocks of data with large stepovers. Empirically, this is shown to reduce the number of execs by preempting finer-grained efforts later on.</li>
<li>Perform a block deletion pass with decreasing block sizes and stepovers, binary-search-style.</li>
<li>Perform a block deletion pass with decreasing block sizes and stepovers, binary-search-style.</li>
<li>Perform a block deletion pass with decreasing block sizes and stepovers, binary-search-style.</li>
</ol>
</blockquote>
<p>å®é™…çš„æœ€å°åŒ–ç®—æ³•æ˜¯ï¼š</p>
<ol>
<li>å°è¯•å°†å…·æœ‰å¤§è·¨è·çš„å¤§æ•°æ®å—å½’é›¶ã€‚ä»ç»éªŒä¸Šè®²ï¼Œè¿™å¯ä»¥é€šè¿‡æŠ¢å ä»¥åæ›´ç»†ç²’åº¦çš„å·¥ä½œæ¥å‡å°‘<code>exec</code>çš„æ•°é‡ã€‚</li>
<li>ä»¥é€’å‡çš„å—å¤§å°å’Œæ­¥è·æ‰§è¡Œå—åˆ é™¤è¿‡ç¨‹ï¼Œé‡‡ç”¨äºŒåˆ†æœç´¢æ–¹å¼ã€‚</li>
<li>é€šè¿‡è®¡ç®—å”¯ä¸€å­—ç¬¦å¹¶å°è¯•å°†æ¯ä¸ªå­—ç¬¦æ‰¹é‡æ›¿æ¢ä¸ºé›¶å€¼æ¥æ‰§è¡Œå­—æ¯è§„èŒƒåŒ–ã€‚</li>
<li>æœ€åï¼Œå¯¹éé›¶å­—èŠ‚æ‰§è¡Œé€å­—èŠ‚å½’ä¸€åŒ–ã€‚</li>
</ol>
<blockquote>
<p>Instead of zeroing with a 0x00 byte, afl-tmin uses the ASCII digit â€˜0â€™. This<br>is done because such a modification is much less likely to interfere with<br>text parsing, so it is more likely to result in successful minimization of<br>text files.</p>
</blockquote>
<p>afl-tmin ä½¿ç”¨ ASCII æ•°å­—â€œ0â€ï¼Œè€Œä¸æ˜¯ä½¿ç”¨ 0x00 å­—èŠ‚è¿›è¡Œæ¸…é›¶ã€‚è¿™æ ·åšæ˜¯å› ä¸ºè¿™æ ·çš„ä¿®æ”¹ä¸å¤ªå¯èƒ½å¹²æ‰°æ–‡æœ¬è§£æï¼Œå› æ­¤æ›´æœ‰å¯èƒ½æˆåŠŸæœ€å°åŒ–æ–‡æœ¬æ–‡ä»¶ã€‚</p>
<blockquote>
<p>The algorithm used here is less involved than some other test case<br>minimization approaches proposed in academic work, but requires far fewer<br>executions and tends to produce comparable results in most real-world<br>applications.</p>
</blockquote>
<p>è¿™é‡Œä½¿ç”¨çš„ç®—æ³•æ¯”å­¦æœ¯å·¥ä½œä¸­æå‡ºçš„å…¶ä»–ä¸€äº›æµ‹è¯•ç”¨ä¾‹æœ€å°åŒ–æ–¹æ³•æ¶‰åŠçš„ç¨‹åº¦è¦å°‘ï¼Œä½†éœ€è¦çš„æ‰§è¡Œæ¬¡æ•°è¦å°‘å¾—å¤šï¼Œå¹¶ä¸”å¾€å¾€ä¼šåœ¨å¤§å¤šæ•°å®é™…åº”ç”¨ä¸­äº§ç”Ÿå¯æ¯”è¾ƒçš„ç»“æœã€‚</p>
<h2 id="6ï¼‰-Fuzzing-strategies-æ¨¡ç³Šæµ‹è¯•ç­–ç•¥"><a href="#6ï¼‰-Fuzzing-strategies-æ¨¡ç³Šæµ‹è¯•ç­–ç•¥" class="headerlink" title="6ï¼‰ Fuzzing strategies æ¨¡ç³Šæµ‹è¯•ç­–ç•¥"></a>6ï¼‰ Fuzzing strategies æ¨¡ç³Šæµ‹è¯•ç­–ç•¥</h2><blockquote>
<p>The feedback provided by the instrumentation makes it easy to understand the<br>value of various fuzzing strategies and optimize their parameters so that they<br>work equally well across a wide range of file types. The strategies used by<br>afl-fuzz are generally format-agnostic and are discussed in more detail here:<br><a target="_blank" rel="noopener" href="http://lcamtuf.blogspot.com/2014/08/binary-fuzzing-strategies-what-works.html">http://lcamtuf.blogspot.com/2014/08/binary-fuzzing-strategies-what-works.html</a></p>
</blockquote>
<p>ä»ªå™¨æä¾›çš„åé¦ˆä½¿æ‚¨å¯ä»¥è½»æ¾äº†è§£å„ç§æ¨¡ç³Šæµ‹è¯•ç­–ç•¥çš„ä»·å€¼å¹¶ä¼˜åŒ–å…¶å‚æ•°ï¼Œä»¥ä¾¿å®ƒä»¬åœ¨å„ç§æ–‡ä»¶ç±»å‹ä¸ŠåŒæ ·æœ‰æ•ˆã€‚ afl-fuzz ä½¿ç”¨çš„ç­–ç•¥é€šå¸¸ä¸æ ¼å¼æ— å…³ï¼Œè¿™é‡Œæ›´è¯¦ç»†åœ°è®¨è®º:<br><a target="_blank" rel="noopener" href="http://lcamtuf.blogspot.com/2014/08/binary-fuzzing-strategies-what-works.html">http://lcamtuf.blogspot.com/2014/08/binary-fuzzing-strategies-what-works.html</a></p>
<blockquote>
<p>It is somewhat notable that especially early on, most of the work done by<br>afl-fuzz is actually highly deterministic, and progresses to random stacked<br>modifications and test case splicing only at a later stage. The deterministic<br>strategies include:</p>
</blockquote>
<ul>
<li>Sequential bit flips with varying lengths and stepovers,</li>
<li>Sequential addition and subtraction of small integers,</li>
<li>Sequential addition and subtraction of small integers,</li>
</ul>
<p>å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œç‰¹åˆ«æ˜¯åœ¨æ—©æœŸï¼Œafl-fuzz æ‰€åšçš„å¤§éƒ¨åˆ†å·¥ä½œå®é™…ä¸Šæ˜¯é«˜åº¦ç¡®å®šæ€§çš„ï¼Œå¹¶ä¸”ä»…åœ¨åæœŸé˜¶æ®µæ‰ä¼šè¿›å±•åˆ°éšæœºå †å ä¿®æ”¹å’Œæµ‹è¯•ç”¨ä¾‹æ‹¼æ¥ã€‚ç¡®å®šæ€§ç­–ç•¥åŒ…æ‹¬ï¼š</p>
<ul>
<li>é¡ºåºå¯¹ä¸åŒé•¿åº¦å’Œæ­¥è·çš„ä½è¿›è¡Œåè½¬</li>
<li>é¡ºåºå¯¹å°æ•´æ•°çš„åŠ å‡æ³•</li>
<li>é¡ºåºæ’å…¥å·²çŸ¥çš„interestingæ•´æ•°ï¼ˆ0ã€1ã€INT_MAXç­‰ï¼‰</li>
</ul>
<blockquote>
<p>The purpose of opening with deterministic steps is related to their tendency to<br>produce compact test cases and small diffs between the non-crashing and crashing<br>inputs.</p>
</blockquote>
<p>ä»¥ç¡®å®šæ€§æ­¥éª¤æ‰“å¼€çš„ç›®çš„ä¸å®ƒä»¬ç”Ÿæˆç´§å‡‘æµ‹è¯•ç”¨ä¾‹ä»¥åŠéå´©æºƒå’Œå´©æºƒè¾“å…¥ä¹‹é—´çš„å°å·®å¼‚çš„å€¾å‘æœ‰å…³ã€‚</p>
<blockquote>
<p>With deterministic fuzzing out of the way, the non-deterministic steps include<br>stacked bit flips, insertions, deletions, arithmetics, and splicing of different<br>test cases.</p>
</blockquote>
<p>ä»‹ç»å®Œç¡®å®šæ€§æ¨¡ç³Šæµ‹è¯•æ­¥éª¤ï¼Œéç¡®å®šæ€§æ­¥éª¤åŒ…æ‹¬å †å ä½ç¿»è½¬ã€æ’å…¥ã€åˆ é™¤ã€ç®—æœ¯å’Œä¸åŒæµ‹è¯•ç”¨ä¾‹çš„æ‹¼æ¥ã€‚</p>
<blockquote>
<p>The relative yields and execve() costs of all these strategies have been<br>investigated and are discussed in the aforementioned blog post.</p>
</blockquote>
<p>æ‰€æœ‰è¿™äº›ç­–ç•¥çš„ç›¸å¯¹æ”¶ç›Šç‡å’Œ <code>execve()</code>çš„æˆæœ¬éƒ½å·²åœ¨ä¸Šè¿°åšå®¢æ–‡ç« ä¸­è¿›è¡Œäº†ç ”ç©¶å’Œè®¨è®ºã€‚</p>
<blockquote>
<p>For the reasons discussed in historical_notes.txt (chiefly, performance,<br>simplicity, and reliability), AFL generally does not try to reason about the<br>relationship between specific mutations and program states; the fuzzing steps<br>are nominally blind, and are guided only by the evolutionary design of the<br>input queue.</p>
</blockquote>
<p>æ­£å¦‚ Historical_notes.txt ä¸­è®¨è®ºçš„åŸå› ï¼ˆä¸»è¦æ˜¯æ€§èƒ½ã€ç®€å•æ€§å’Œå¯é æ€§ï¼‰ï¼ŒAFL é€šå¸¸ä¸ä¼šå°è¯•æ¨ç†ç‰¹å®šçªå˜å’Œç¨‹åºçŠ¶æ€ä¹‹é—´çš„å…³ç³»ï¼›æ¨¡ç³Šæµ‹è¯•æ­¥éª¤åä¹‰ä¸Šæ˜¯ç›²ç›®çš„ï¼Œå¹¶ä¸”ä»…å—è¾“å…¥é˜Ÿåˆ—çš„è¿›åŒ–è®¾è®¡çš„æŒ‡å¯¼ã€‚</p>
<blockquote>
<p>That said, there is one (trivial) exception to this rule: when a new queue<br>entry goes through the initial set of deterministic fuzzing steps, and tweaks to<br>some regions in the file are observed to have no effect on the checksum of the<br>execution path, they may be excluded from the remaining phases of<br>deterministic fuzzing - and the fuzzer may proceed straight to random tweaks.<br>Especially for verbose, human-readable data formats, this can reduce the number<br>of execs by 10-40% or so without an appreciable drop in coverage. In extreme<br>cases, such as normally block-aligned tar archives, the gains can be as high as<br>90%.</p>
</blockquote>
<p>ä¹Ÿå°±æ˜¯è¯´ï¼Œæ­¤è§„åˆ™æœ‰ä¸€ä¸ªï¼ˆå¾®ä¸è¶³é“çš„ï¼‰ä¾‹å¤–ï¼šå½“æ–°é˜Ÿåˆ—æ¡ç›®ç»å†åˆå§‹çš„ä¸€ç»„ç¡®å®šæ€§æ¨¡ç³Šæ­¥éª¤æ—¶ï¼Œè§‚å¯Ÿåˆ°å¯¹æ–‡ä»¶ä¸­æŸäº›åŒºåŸŸçš„è°ƒæ•´å¯¹æ‰§è¡Œè·¯å¾„çš„æ ¡éªŒå’Œæ²¡æœ‰å½±å“ï¼Œå®ƒä»¬å¯èƒ½ä¼šè¢«æ’é™¤åœ¨ç¡®å®šæ€§æ¨¡ç³Šæµ‹è¯•çš„å‰©ä½™é˜¶æ®µä¹‹å¤– - å¹¶ä¸”æ¨¡ç³Šå™¨å¯èƒ½ä¼šç›´æ¥è¿›è¡Œéšæœºè°ƒæ•´ã€‚ç‰¹åˆ«æ˜¯å¯¹äºå†—é•¿çš„ã€äººç±»å¯è¯»çš„æ•°æ®æ ¼å¼ï¼Œè¿™å¯ä»¥å°†æ‰§è¡Œæ•°é‡å‡å°‘ 10-40% å·¦å³ï¼Œè€Œè¦†ç›–ç‡ä¸ä¼šæ˜æ˜¾ä¸‹é™ã€‚åœ¨æç«¯æƒ…å†µä¸‹ï¼Œä¾‹å¦‚é€šå¸¸å—å¯¹é½çš„ tar å­˜æ¡£ï¼Œå¢ç›Šå¯é«˜è¾¾ 90%ã€‚</p>
<blockquote>
<p>Because the underlying â€œeffector mapsâ€ are local every queue entry and remain<br>in force only during deterministic stages that do not alter the size or the<br>general layout of the underlying file, this mechanism appears to work very<br>reliably and proved to be simple to implement.</p>
</blockquote>
<p>ç”±äºåº•å±‚â€œæ•ˆåº”å™¨æ˜ å°„â€æ˜¯æ¯ä¸ªé˜Ÿåˆ—æ¡ç›®çš„æœ¬åœ°ä¿¡æ¯ï¼Œå¹¶ä¸”ä»…åœ¨ä¸æ”¹å˜åº•å±‚æ–‡ä»¶çš„å¤§å°æˆ–æ€»ä½“å¸ƒå±€çš„ç¡®å®šæ€§é˜¶æ®µä¿æŒæœ‰æ•ˆï¼Œå› æ­¤è¯¥æœºåˆ¶ä¼¼ä¹å·¥ä½œéå¸¸å¯é ï¼Œå¹¶ä¸”è¢«è¯æ˜æ˜“äºå®ç°ã€‚</p>
<h2 id="7ï¼‰Dictionaries-å­—å…¸"><a href="#7ï¼‰Dictionaries-å­—å…¸" class="headerlink" title="7ï¼‰Dictionaries å­—å…¸"></a>7ï¼‰Dictionaries å­—å…¸</h2><blockquote>
<p>The feedback provided by the instrumentation makes it easy to automatically<br>identify syntax tokens in some types of input files, and to detect that certain<br>combinations of predefined or auto-detected dictionary terms constitute a<br>valid grammar for the tested parser.</p>
</blockquote>
<p>ä»ªå™¨æä¾›çš„åé¦ˆä½¿å¾—è‡ªåŠ¨è¯†åˆ«æŸäº›ç±»å‹çš„è¾“å…¥æ–‡ä»¶ä¸­çš„è¯­æ³•æ ‡è®°å˜å¾—å®¹æ˜“ï¼Œå¹¶æ£€æµ‹é¢„å®šä¹‰æˆ–è‡ªåŠ¨æ£€æµ‹çš„å­—å…¸æœ¯è¯­çš„æŸäº›ç»„åˆæ˜¯å¦æ„æˆäº†æµ‹è¯•è§£æå™¨çš„æœ‰æ•ˆè¯­æ³•ã€‚</p>
<p>æœ‰å…³å¦‚ä½•åœ¨ afl-fuzz ä¸­å®ç°è¿™äº›åŠŸèƒ½çš„è®¨è®ºå¯ä»¥åœ¨æ­¤å¤„æ‰¾åˆ°:<br><a target="_blank" rel="noopener" href="http://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html">http://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html</a></p>
<blockquote>
<p>In essence, when basic, typically easily-obtained syntax tokens are combined<br>together in a purely random manner, the instrumentation and the evolutionary<br>design of the queue together provide a feedback mechanism to differentiate<br>between meaningless mutations and ones that trigger new behaviors in the<br>instrumented code - and to incrementally build more complex syntax on top of<br>this discovery.</p>
</blockquote>
<p>æœ¬è´¨ä¸Šï¼Œå½“åŸºæœ¬çš„ã€é€šå¸¸å®¹æ˜“è·å¾—çš„è¯­æ³•æ ‡è®°ä»¥çº¯ç²¹éšæœºçš„æ–¹å¼ç»„åˆåœ¨ä¸€èµ·æ—¶ï¼Œé˜Ÿåˆ—çš„æ£€æµ‹å’Œè¿›åŒ–è®¾è®¡ä¸€èµ·æä¾›äº†ä¸€ç§åé¦ˆæœºåˆ¶ï¼Œä»¥åŒºåˆ†æ— æ„ä¹‰çš„çªå˜å’Œåœ¨æ£€æµ‹ä»£ç ä¸­è§¦å‘æ–°è¡Œä¸ºçš„çªå˜- å¹¶åœ¨æ­¤å‘ç°çš„åŸºç¡€ä¸Šé€æ­¥æ„å»ºæ›´å¤æ‚çš„è¯­æ³•ã€‚</p>
<blockquote>
<p>The dictionaries have been shown to enable the fuzzer to rapidly reconstruct<br>the grammar of highly verbose and complex languages such as JavaScript, SQL,<br>or XML; several examples of generated SQL statements are given in the blog<br>post mentioned above.</p>
</blockquote>
<p>äº‹å®è¯æ˜ï¼Œå­—å…¸å¯ä»¥ä½¿æ¨¡ç³Šå™¨å¿«é€Ÿé‡å»ºé«˜åº¦å†—é•¿å’Œå¤æ‚çš„è¯­è¨€ï¼ˆä¾‹å¦‚ JavaScriptã€SQL æˆ– XMLï¼‰çš„è¯­æ³•ï¼›ä¸Šé¢æåˆ°çš„åšå®¢æ–‡ç« ä¸­ç»™å‡ºäº†ç”Ÿæˆ SQL è¯­å¥çš„å‡ ä¸ªç¤ºä¾‹ã€‚</p>
<blockquote>
<p>Interestingly, the AFL instrumentation also allows the fuzzer to automatically<br>isolate syntax tokens already present in an input file. It can do so by looking<br>for run of bytes that, when flipped, produce a consistent change to the<br>programâ€™s execution path; this is suggestive of an underlying atomic comparison<br>to a predefined value baked into the code. The fuzzer relies on this signal<br>to build compact â€œauto dictionariesâ€ that are then used in conjunction with<br>other fuzzing strategies.</p>
</blockquote>
<p>æœ‰è¶£çš„æ˜¯ï¼ŒAFL æ£€æµ‹è¿˜å…è®¸æ¨¡ç³Šå™¨è‡ªåŠ¨éš”ç¦»è¾“å…¥æ–‡ä»¶ä¸­å·²å­˜åœ¨çš„è¯­æ³•æ ‡è®°ã€‚å®ƒå¯ä»¥é€šè¿‡æŸ¥æ‰¾å­—èŠ‚è¿è¡Œæ¥å®ç°è¿™ä¸€ç‚¹ï¼Œè¿™äº›å­—èŠ‚åœ¨ç¿»è½¬æ—¶ä¼šå¯¹ç¨‹åºçš„æ‰§è¡Œè·¯å¾„äº§ç”Ÿä¸€è‡´çš„æ›´æ”¹ï¼›è¿™è¡¨æ˜ä»£ç ä¸­é¢„å®šä¹‰å€¼å­˜åœ¨åº•å±‚åŸå­åŒ–çš„æ¯”è¾ƒã€‚æ¨¡ç³Šå™¨ä¾é è¿™ä¸ªä¿¡å·æ¥æ„å»ºç´§å‡‘çš„â€œè‡ªåŠ¨å­—å…¸â€ï¼Œç„¶åä¸å…¶ä»–æ¨¡ç³Šç­–ç•¥ç»“åˆä½¿ç”¨ã€‚</p>
<h2 id="8ï¼‰De-duping-crashes-é‡å¤æ•°æ®åˆ é™¤å´©æºƒ"><a href="#8ï¼‰De-duping-crashes-é‡å¤æ•°æ®åˆ é™¤å´©æºƒ" class="headerlink" title="8ï¼‰De-duping crashes é‡å¤æ•°æ®åˆ é™¤å´©æºƒ"></a>8ï¼‰De-duping crashes é‡å¤æ•°æ®åˆ é™¤å´©æºƒ</h2><blockquote>
<p>De-duplication of crashes is one of the more important problems for any<br>competent fuzzing tool. Many of the naive approaches run into problems; in<br>particular, looking just at the faulting address may lead to completely<br>unrelated issues being clustered together if the fault happens in a common<br>library function (say, strcmp, strcpy); while checksumming call stack<br>backtraces can lead to extreme crash count inflation if the fault can be<br>reached through a number of different, possibly recursive code paths.</p>
</blockquote>
<p>å¯¹äºä»»ä½•æœ‰èƒ½åŠ›çš„æ¨¡ç³Šæµ‹è¯•å·¥å…·æ¥è¯´ï¼Œå¦‚ä½•åˆ é™¤é‡å¤æ•°æ®æ˜¯æœ€é‡è¦çš„é—®é¢˜ä¹‹ä¸€ã€‚è®¸å¤šç®€å•çš„æ–¹æ³•éƒ½ä¼šé‡åˆ°é—®é¢˜ã€‚å°¤å…¶æ˜¯ï¼Œå¦‚æœæ•…éšœå‘ç”Ÿåœ¨å…¬å…±åº“å‡½æ•°ï¼ˆä¾‹å¦‚ strcmpã€strcpyï¼‰ä¸­ï¼Œåˆ™ä»…æŸ¥çœ‹æ•…éšœåœ°å€å¯èƒ½ä¼šå¯¼è‡´å®Œå…¨ä¸ç›¸å…³çš„é—®é¢˜èšé›†åœ¨ä¸€èµ·ï¼›å¦‚æœå¯ä»¥é€šè¿‡è®¸å¤šä¸åŒçš„ã€å¯èƒ½æ˜¯é€’å½’çš„ä»£ç è·¯å¾„åˆ°è¾¾æ•…éšœï¼Œåˆ™å¯¹è°ƒç”¨å †æ ˆå›æº¯è¿›è¡Œæ ¡éªŒå’Œå¯èƒ½ä¼šå¯¼è‡´å¤§é‡å¼‚å¸¸çš„å´©æºƒè®¡æ•°ã€‚</p>
<blockquote>
<p>The solution implemented in afl-fuzz considers a crash unique if any of two<br>conditions are met:</p>
<ul>
<li>The crash trace includes a tuple not seen in any of the previous crashes,</li>
<li>The crash trace is missing a tuple that was always present in earlier faults.<br>å¦‚æœæ»¡è¶³ä¸‹åˆ—ä¸¤ä¸ªæ¡ä»¶çš„ä»»æ„ä¸€ç§ï¼Œafl-fuzzä¸­å®ç°çš„è§£å†³æ–¹æ¡ˆå°±ä¼šå°†å…¶è®¤å®šä¸ºä¸€ç§crash</li>
</ul>
</blockquote>
<ul>
<li>è‹¥è¿™ä¸ªcrashåŒ…å«ä¸€ä¸ªä»æœªåœ¨å…¶ä»–crashä¸­å‡ºç°è¿‡çš„å…ƒç»„</li>
<li>è‹¥è¿™ä¸ªcrashä¸åŒ…å«ä¸€ä¸ªæ€»æ˜¯åœ¨å…¶ä»–crashä¸­å‡ºç°çš„å…ƒç»„</li>
</ul>
<blockquote>
<p>The approach is vulnerable to some path count inflation early on, but exhibits<br>a very strong self-limiting effect, similar to the execution path analysis<br>logic that is the cornerstone of afl-fuzz.</p>
</blockquote>
<p>è¯¥æ–¹æ³•æ—©æœŸå®¹æ˜“å—åˆ°è·¯å¾„è®¡æ•°è†¨èƒ€çš„å½±å“ï¼Œä½†å…¶è¡¨ç°å‡ºéå¸¸å¼ºçš„è‡ªæˆ‘é™åˆ¶æ•ˆåº”ï¼ŒåŒæ ·ä½“ç°åœ¨ afl-fuzz åŸºçŸ³çš„æ‰§è¡Œè·¯å¾„åˆ†æé€»è¾‘ã€‚</p>
<h2 id="9ï¼‰Investigating-crashes-è°ƒæŸ¥å´©æºƒ"><a href="#9ï¼‰Investigating-crashes-è°ƒæŸ¥å´©æºƒ" class="headerlink" title="9ï¼‰Investigating crashes è°ƒæŸ¥å´©æºƒ"></a>9ï¼‰Investigating crashes è°ƒæŸ¥å´©æºƒ</h2><blockquote>
<p>The exploitability of many types of crashes can be ambiguous; afl-fuzz tries<br>to address this by providing a crash exploration mode where a known-faulting<br>test case is fuzzed in a manner very similar to the normal operation of the<br>fuzzer, but with a constraint that causes any non-crashing mutations to be<br>thrown away.</p>
</blockquote>
<p>è®¸å¤šç±»å‹çš„å´©æºƒçš„å¯åˆ©ç”¨æ€§å¯èƒ½æ˜¯ä¸æ˜ç¡®çš„ï¼› afl-fuzz è¯•å›¾é€šè¿‡æä¾›å´©æºƒæ¢ç´¢æ¨¡å¼æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå…¶ä¸­å·²çŸ¥æ•…éšœçš„æµ‹è¯•ç”¨ä¾‹ä»¥ä¸æ¨¡ç³Šå™¨æ­£å¸¸æ“ä½œéå¸¸ç›¸ä¼¼çš„æ–¹å¼è¿›è¡Œæ¨¡ç³Šæµ‹è¯•ï¼Œä½†æœ‰ä¸€ä¸ªçº¦æŸï¼Œå¯¼è‡´ä»»ä½•éå´©æºƒçš„çªå˜éƒ½è¢«ä¸¢å¼ƒã€‚</p>
<p>æœ‰å…³æ­¤æ–¹æ³•ä»·å€¼çš„è¯¦ç»†è®¨è®ºå¯ä»¥åœ¨æ­¤å¤„æ‰¾åˆ°</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://lcamtuf.blogspot.com/2014/11/afl-fuzz-crash-exploration-mode.html">http://lcamtuf.blogspot.com/2014/11/afl-fuzz-crash-exploration-mode.html</a></li>
</ul>
<blockquote>
<p>The method uses instrumentation feedback to explore the state of the crashing<br>program to get past the ambiguous faulting condition and then isolate the<br>newly-found inputs for human review.</p>
</blockquote>
<p>è¯¥æ–¹æ³•ä½¿ç”¨ä»ªå™¨åé¦ˆæ¥æ¢ç´¢å´©æºƒç¨‹åºçš„çŠ¶æ€ï¼Œä»¥å…‹æœæ¨¡ç³Šçš„æ•…éšœæ¡ä»¶ï¼Œç„¶åéš”ç¦»æ–°å‘ç°çš„è¾“å…¥ä»¥ä¾›äººå·¥å®¡æŸ¥ã€‚</p>
<blockquote>
<p>On the subject of crashes, it is worth noting that in contrast to normal<br>queue entries, crashing inputs are <em>not</em> trimmed; they are kept exactly as<br>discovered to make it easier to compare them to the parent, non-crashing entry<br>in the queue. That said, afl-tmin can be used to shrink them at will.</p>
</blockquote>
<p>å…³äºå´©æºƒé—®é¢˜ï¼Œå€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œä¸æ­£å¸¸é˜Ÿåˆ—æ¡ç›®ç›¸æ¯”ï¼Œå´©æºƒè¾“å…¥<strong>ä¸ä¼š</strong>è¢«ä¿®å‰ªï¼›å®ƒä»¬å®Œå…¨æŒ‰ç…§å‘ç°çš„æ–¹å¼ä¿å­˜ï¼Œä»¥ä¾¿æ›´å®¹æ˜“å°†å®ƒä»¬ä¸é˜Ÿåˆ—ä¸­çš„çˆ¶éå´©æºƒæ¡ç›®è¿›è¡Œæ¯”è¾ƒã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œafl-tmin å¯ä»¥ç”¨æ¥éšæ„ç¼©å°å®ƒä»¬ã€‚</p>
<h2 id="10ï¼‰The-fork-server"><a href="#10ï¼‰The-fork-server" class="headerlink" title="10ï¼‰The fork server"></a>10ï¼‰The fork server</h2><blockquote>
<p>To improve performance, afl-fuzz uses a â€œfork serverâ€, where the fuzzed process<br>goes through execve(), linking, and libc initialization only once, and is then<br>cloned from a stopped process image by leveraging copy-on-write. The<br>implementation is described in more detail here:</p>
</blockquote>
<p>ä¸ºäº†æé«˜æ€§èƒ½ï¼Œafl-fuzz ä½¿ç”¨<strong>â€œfork serverâ€</strong>ï¼Œå…¶ä¸­æ¨¡ç³ŠåŒ–è¿›ç¨‹ä»…æ‰§è¡Œä¸€æ¬¡ execve()ã€é“¾æ¥å’Œ libc åˆå§‹åŒ–ï¼Œç„¶åé€šè¿‡åˆ©ç”¨<strong>copy-on-write</strong>ä»åœæ­¢çš„è¿›ç¨‹æ˜ åƒè¿›è¡Œå…‹éš†ã€‚è¿™é‡Œæ›´è¯¦ç»†åœ°æè¿°äº†è¯¥å®ç°ï¼š</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html">http://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html</a></li>
</ul>
<blockquote>
<p>The fork server is an integral aspect of the injected instrumentation and<br>simply stops at the first instrumented function to await commands from<br>afl-fuzz.</p>
</blockquote>
<p>fork serveræ˜¯æ³¨å…¥æ£€æµ‹çš„ä¸€ä¸ªç»„æˆéƒ¨åˆ†ï¼Œå®ƒåªæ˜¯åœ¨ç¬¬ä¸€ä¸ªæ£€æµ‹å‡½æ•°å¤„åœæ­¢ä»¥ç­‰å¾…æ¥è‡ª afl-fuzz çš„å‘½ä»¤ã€‚</p>
<blockquote>
<p>With fast targets, the fork server can offer considerable performance gains,<br>usually between 1.5x and 2x. It is also possible to:</p>
<ul>
<li>Use the fork server in manual (â€œdeferredâ€) mode, skipping over larger, user-selected chunks of initialization code. It requires very modest code changes to the targeted program, and With some targets, can produce 10x+ performance gains.</li>
<li>Enable â€œpersistentâ€ mode, where a single process is used to try out multiple inputs, greatly limiting the overhead of repetitive fork() calls. This generally requires some code changes to the targeted program, but can improve the performance of fast targets by a factor of 5 or more - approximating the benefits of in-process fuzzing jobs while still maintaining very robust isolation between the fuzzer process and the targeted binary.</li>
</ul>
</blockquote>
<p>å¯¹äºfastç›®æ ‡ï¼Œfork serverå¯ä»¥æä¾›ç›¸å½“å¤§çš„æ€§èƒ½æå‡ï¼Œé€šå¸¸åœ¨1.5å€åˆ°2å€ä¹‹é—´ã€‚è¿˜å¯ä»¥ï¼š</p>
<ul>
<li>åœ¨æ‰‹åŠ¨çš„ï¼ˆâ€œdeferredâ€ï¼‰æ¨¡å¼ä¸‹ä½¿ç”¨fork serverï¼Œè·³è¿‡è¾ƒå¤§çš„ã€ç”¨æˆ·é€‰æ‹©çš„åˆå§‹åŒ–ä»£ç å—ã€‚å®ƒéœ€è¦å¯¹ç›®æ ‡ç¨‹åºè¿›è¡Œæ°åˆ°å¥½å¤„çš„ä»£ç æ›´æ”¹ï¼Œå¹¶ä¸”å¯¹äºæŸäº›ç›®æ ‡ï¼Œå¯ä»¥äº§ç”Ÿ10å€ä»¥ä¸Šçš„æ€§èƒ½æå‡</li>
<li>å¯ç”¨â€œpersistentâ€æ¨¡å¼ï¼Œå…¶ä¸­å•ä¸ªè¿›ç¨‹ç”¨äºå°è¯•å¤šä¸ªè¾“å…¥ï¼Œæå¤§çš„é™åˆ¶äº†é‡å¤<code>fork()</code>è°ƒç”¨çš„å¼€é”€ã€‚è¿™é€šå¸¸éœ€è¦å¯¹ç›®æ ‡ç¨‹åºè¿›è¡Œä¸€äº›ä»£ç æ›´æ”¹ï¼Œå¤§å¯ä»¥å°†fastç›®æ ‡çš„æ€§èƒ½æé«˜5å€æˆ–è€…æ›´å¤š - è¿‘ä¼¼äºè¿›ç¨‹å†…æ¨¡ç³Šæµ‹è¯•ä½œä¸šçš„å¥½å¤„ï¼ŒåŒæ—¶ä»ç„¶ä¿æŒfuzzerè¿›ç¨‹å’Œç›®æ ‡äºŒè¿›åˆ¶æ–‡ä»¶ä¹‹é—´å·¨å¤§çš„éš”ç¦»ã€‚</li>
</ul>
<h2 id="å…¶ä»–éƒ¨åˆ†"><a href="#å…¶ä»–éƒ¨åˆ†" class="headerlink" title="å…¶ä»–éƒ¨åˆ†"></a>å…¶ä»–éƒ¨åˆ†</h2><p>å‰©ä¸‹3ç« æ„Ÿè§‰ä¸æ˜¯å¾ˆé‡è¦ï¼Œå¯ä»¥è‡ªå·±å»çœ‹çœ‹ã€‚ä¹‹åæœ‰ç©ºå†è¡¥ä¸Šè¿™éƒ¨åˆ†å§</p>

</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
                <div class="icon arrow-left"></div>
                <div class="post-link">
                    <a href="/2023/08/29/ASAN%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">Prev</a>
                </div>
            
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2023/08/22/%E3%80%90fuzz%20trick%E3%80%91%E5%88%A9%E7%94%A8LCOV%E6%B5%8B%E9%87%8F%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

    
      <div class="post-comment">

    
        <div id="vcomments"></div>
        <script>
            var META = ['nick', 'mail', 'link'];
            var meta = 'nick,mail';
            meta = meta.split(',').filter(item => {
                return META.includes(item);
            });
            new Valine({
                el: '#vcomments',
                appId: 'rb5WOYmmPvNLWkXLJIiqi1p0-gzGzoHsz',
                appKey: 'B0j55vucTVteHiiUJeIL8Vx8',
                lang: 'zh-CN',
                placeholder: 'è¿™é‡Œæ˜¯è¯„è®ºåŒº:)',
                avatar: 'mp',
                meta: meta
            })
        </script>    
     

     
    
    

</div>
     
  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
            
            
                Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/zoeingwingkei/frame/">Frame</a>
                
        </div>
    </div>
</div>

    </div>

    
      <div class="search-popup">
    <div class="search-popup-overlay">  
    </div>
    <div class="search-popup-window" >
        <div class="search-header">
            <div class="search-input-container">
              <input autocomplete="off" autocapitalize="off" maxlength="80"
                     placeholder="Search Anything" spellcheck="false"
                     type="search" class="search-input">
            </div>
            <div class="search-close-btn">
                <div class="icon close-btn"></div>
            </div>
        </div>
        <div class="search-result-container">
        </div>
    </div>
</div>

<script>
    const searchConfig = {
        path             : "/search.xml",
        top_n_per_article: "1",
        unescape         : "false",
        trigger: "auto",
        preload: "false"
    }
</script>
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js"></script>
<script src="/js/search.js"></script>
    
    

  <!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?Loora1N";
            var git_color =['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'];
            var git_user ="Loora1N";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/about/'){
                console.log('å·²æŒ‚è½½github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // æ— æŠ¥é”™ï¼Œä½†ä¸å½±å“ä½¿ç”¨(æ”¯æŒpjaxè·³è½¬)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // æœ‰æŠ¥é”™ï¼Œä½†ä¸å½±å“ä½¿ç”¨(æ”¯æŒpjaxè·³è½¬)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><!-- hexo injector body_end end --></body>
</html>
