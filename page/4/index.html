<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <title>Loora1N&#39;s Blog | 鹭雨 | </title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="header">
    <a class="logo" href="/">Loora1N&#39;s Blog | 鹭雨</a>
    <ul class="nav">
        
        <li><a href="/">首页</a></li>
        
        <li><a href="/archives">归档</a></li>
        
        <li><a href="/about">关于</a></li>
        
        <li><a href="/links">友链</a></li>
        
    </ul>
</div>
                
                <div class="post-list">
    
    <div class="post">
        <a class="post-title" href="/2023/11/16/%E3%80%90IOT%E3%80%91%E5%9B%BA%E4%BB%B6%E8%A7%A3%E5%8C%85%E5%8F%8A%E6%89%93%E5%8C%85/">【IOT】固件解包及打包</a>
        <div class="post-except">
            解包binwalk -eM file.bin

打包首先查看原.bin文件文件结构

然后切割出文件目录之前的头部
sudo dd if=file.bin of=head.bin bs=1 skip=0 count=1376400
#if是原固件，of是输出文件，bs是单位长度，skip是偏移量，count是分区大小取到文件目录之前

正常解包，然后更改文件内容，随后制作文件目录的bin文件
sudo mksquashfs squashfs-root rootfs.bin -
            <a class="read-more" href="/2023/11/16/%E3%80%90IOT%E3%80%91%E5%9B%BA%E4%BB%B6%E8%A7%A3%E5%8C%85%E5%8F%8A%E6%89%93%E5%8C%85/"> ... </a>
        </div>
        <div class="post-date">2023.11.16</div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2023/11/16/%E3%80%90IOT%E3%80%91%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E5%A4%87%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90/">【IOT】嵌入式设备固件分析</a>
        <div class="post-except">
            嵌入式设备固件一般可以分为两类：

有文件系统（如路由器固件这种）
无文件系统（如STM32这种嵌入式设备固件，程序直接存放在flash中）

针对第一类固件，分析起来比较简单，直接binwalk分离。然后去逆向对应的服务对应的二进制程序即可，也不需要考虑程序的加载地址。
而对于第二类固件，往往就会比较复杂，需要分析程序的加载地址，也需要考虑外设的地址映射。

本文将从SCTF2020的题目Password Lock入手，分析STM32固件作为入门

题目信息这是一个STM3
            <a class="read-more" href="/2023/11/16/%E3%80%90IOT%E3%80%91%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E5%A4%87%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90/"> ... </a>
        </div>
        <div class="post-date">2023.11.16</div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2023/11/16/%E3%80%90IO_FILE%E3%80%91FSOP/">【IO_FILE】FSOP</a>
        <div class="post-except">
            
FSOP 是 File Stream Oriented Programming 的缩写，根据前面对 FILE 的介绍得知进程内所有的_IO_FILE 结构会使用_chain 域相互连接形成一个链表，这个链表的头部由_IO_list_all 维护。另外由于网络上很多IO_FILE相关博客含有相关glibc源代码，但是并没有源代码的完整部分或者链接。在之后的博客中，我会包含该段代码在哪里可以查看得到。

介绍FSOP 的核心思想就是劫持_IO_list_all 的值来伪造链表和
            <a class="read-more" href="/2023/11/16/%E3%80%90IO_FILE%E3%80%91FSOP/"> ... </a>
        </div>
        <div class="post-date">2023.11.16</div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2023/11/16/%E3%80%90IO_FILE%E3%80%91house%20of%20cat/">【IO_FILE】house of cat</a>
        <div class="post-except">
            前言House of Cat利用了House of emma的虚表偏移修改思想，通过修改虚表指针的偏移，避免了对需要绕过TLS上 _pointer_chk_guard的检测相关的IO函数的调用，转而调用**_IO_wfile_jumps中的_IO_wfile_seekoff函数，然后进入到_IO_switch_to_wget_mode函数中来攻击，从而使得攻击条件和利用变得更为简单。并且house of cat在FSOP的情况下也是可行的，只需修改虚表指针的偏移来调用_IO_
            <a class="read-more" href="/2023/11/16/%E3%80%90IO_FILE%E3%80%91house%20of%20cat/"> ... </a>
        </div>
        <div class="post-date">2023.11.16</div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2023/11/16/%E3%80%90IO_FILE%E3%80%91%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%A6%82%E8%A7%88/">【IO_FILE】源码详解</a>
        <div class="post-except">
            
由于glibc版本的不断更新，常见几种hook在glibc2.34终被舍去，我们急需一种能够在高版本的glibc下仍能有效的getshell方法。而IO_FILE作为heap题目的进阶技能逐渐引起大家注意，吸引了许多大佬投入其中。仅在在2021-2022年期间就出现出现了大量以IO_FILE为基础的调用链利用方式，在比赛中也逐渐成为了当下heap题目的主流getshell方式。本文以glibc2.36为例，从相关结构体以及fopen函数源码入手，详细介绍IO_FILE相关知
            <a class="read-more" href="/2023/11/16/%E3%80%90IO_FILE%E3%80%91%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%A6%82%E8%A7%88/"> ... </a>
        </div>
        <div class="post-date">2023.11.16</div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2023/11/16/%E3%80%90IO_FILE%E3%80%91%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3-part2/">【IO_FILE】源码详解-part2</a>
        <div class="post-except">
            
在上一篇文章中，主要对IO_FILE结构体相关以及fopen函数进行了深入的介绍。本文将继续从glibc2.36源码出发，介绍fread函数相关内容

fread首先是一个宏定义，替换为_IO_fread函数
//	htps://elixir.bootlin.com/glibc/latest/source/stdio-common/getw.c#L21
#define fread(p, m, n, s) _IO_fread (p, m, n, s)

// https://
            <a class="read-more" href="/2023/11/16/%E3%80%90IO_FILE%E3%80%91%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3-part2/"> ... </a>
        </div>
        <div class="post-date">2023.11.16</div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2023/11/16/%E3%80%90Kernel%E3%80%91Linux%20Huge%20Pages/">【Kernel】Linux Huge Pages</a>
        <div class="post-except">
            
在HITCON CTF 2023的一道QEMU escape题目中，利用到了Huge Pages这项技术，借此复现题目的机会，来学习了解下这部分知识。

简介当进程使用 RAM 时，CPU 会将其标记为已被该进程使用。为了提高效率，CPU 以块的形式分配 RAM——4K 字节是许多平台上的默认值。这些块被称为页面。页面可以交换到磁盘等。
由于进程地址空间是虚拟的，CPU和操作系统需要记住哪些页属于哪个进程，以及每个页存储在哪里。页面越多，查找内存映射位置所需的时间就越多。因
            <a class="read-more" href="/2023/11/16/%E3%80%90Kernel%E3%80%91Linux%20Huge%20Pages/"> ... </a>
        </div>
        <div class="post-date">2023.11.16</div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2023/11/16/%E3%80%90Kernel%E3%80%91%E4%B8%80%E4%BA%9B%E5%85%B3%E9%94%AE%E7%BB%93%E6%9E%84%E4%BD%93%E8%AE%B0%E5%BD%95/">【Kernel】一些trick和struct记录（持续更新）</a>
        <div class="post-except">
            pt_regs用于保存用户态–&gt;内核态切换时的用户态信息，在内核态返回时会从pt_regs恢复数据。因而若我们能控制rsp到达此位置，即可以使用用户态寄存器值辅助实现ROP

list_head结构体简单的内核双链表结构，在内核中经常作为实现双链表结构的基础，定义如下
//	https://elixir.bootlin.com/linux/latest/source/include/linux/types.h#L184

struct list_head &#123;

            <a class="read-more" href="/2023/11/16/%E3%80%90Kernel%E3%80%91%E4%B8%80%E4%BA%9B%E5%85%B3%E9%94%AE%E7%BB%93%E6%9E%84%E4%BD%93%E8%AE%B0%E5%BD%95/"> ... </a>
        </div>
        <div class="post-date">2023.11.16</div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2023/11/16/%E3%80%90Linux%20kernel%E5%85%A5%E9%97%A8%E3%80%91%E5%86%85%E6%A0%B8%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95/">【kernel】内核本地调试入门</a>
        <div class="post-except">
            提取vmlinux使用extract-vmlinux脚本提取，脚本下载地址：linux&#x2F;extract-vmlinux at master · torvalds&#x2F;linux (github.com)
./extract-vmlinux ./bzImage &gt; vmlinux

开放调试端口在boot.sh中加入如下参数
-gdb tcp::[port]
#如下
-gdb tcp::1234

启动boot.sh
调试
root权限下运行

gdb .
            <a class="read-more" href="/2023/11/16/%E3%80%90Linux%20kernel%E5%85%A5%E9%97%A8%E3%80%91%E5%86%85%E6%A0%B8%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95/"> ... </a>
        </div>
        <div class="post-date">2023.11.16</div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2023/11/16/%E3%80%90fuzz%20trick%E3%80%91%E5%88%A9%E7%94%A8LCOV%E6%B5%8B%E9%87%8F%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/">【fuzz trick】利用LCOV测量代码覆盖率</a>
        <div class="post-except">
            
本文样例为LibTIFF version 4.0.4，以CVE-2016-9297漏洞举例 

Install直接使用apt安装包即可
sudo apt install lcov

Usage整体流程大致如下
cd ./tiff-4.0.4/
lcov --zerocounters --directory ./
lcov --capture --initial --directory ./ --output-file app.info
../install/bin/tiff
            <a class="read-more" href="/2023/11/16/%E3%80%90fuzz%20trick%E3%80%91%E5%88%A9%E7%94%A8LCOV%E6%B5%8B%E9%87%8F%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/"> ... </a>
        </div>
        <div class="post-date">2023.11.16</div>
    </div>
    
</div>

<div class="paginator">
    <a class="extend prev" rel="prev" href="/page/3/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">下一页</a>
</div>

                <div class="footer">
    <span>Copyright © 2022 Loora1N&#39;s Blog | 鹭雨</span>
    <span>Theme Designed By <a target="_blank" href="https://zheli.design/one-paper">這李設計</a></span>
</div>


<link rel="stylesheet" href="/css/a11y-dark.min.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

            </div>
        </div>
    <!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?Loora1N";
            var git_color =['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'];
            var git_user ="Loora1N";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/about/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><!-- hexo injector body_end end --></body>
</html>